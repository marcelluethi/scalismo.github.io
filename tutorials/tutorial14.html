<html><head><title>scalismo: Rigid alignment</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="University of Basel" /><meta name="description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="image" property="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="og:title" content="scalismo: Rigid alignment" /><meta name="title" property="og:title" content="scalismo: Rigid alignment" /><meta name="og:site_name" content="scalismo" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><link rel="icon" type="image/png" href="/scalismo.github.io/img/favicon.png" /><meta name="twitter:title" content="scalismo: Rigid alignment" /><meta name="twitter:image" content="/scalismo.github.io/img/poster.png" /><meta name="twitter:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/scalismo.github.io/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/scalismo.github.io/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/scalismo.github.io/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/scalismo.github.io/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/scalismo.github.io/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/scalismo.github.io/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/scalismo.github.io/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/scalismo.github.io/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/scalismo.github.io/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/scalismo.github.io/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/scalismo.github.io/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/scalismo.github.io/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/scalismo.github.io/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/scalismo.github.io/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/scalismo.github.io/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/scalismo.github.io/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/scalismo.github.io/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/scalismo.github.io/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/scalismo.github.io/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/scalismo.github.io/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalismo.github.io/highlight/styles/default.css" /><link rel="stylesheet" href="/scalismo.github.io/css/style.css" /><link rel="stylesheet" href="/scalismo.github.io/css/palette.css" /><link rel="stylesheet" href="/scalismo.github.io/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalismo.github.io/" class="brand"><div class="brand-wrapper"><span>scalismo</span></div></a></li> <li><a href="/scalismo.github.io/tutorials/tutorial1.html" class="">Hello Scalismo</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial2.html" class=" active ">Rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial3.html" class="">From meshes to deformation fields</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial4.html" class="">Gaussian processes and Point Distribution Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial5.html" class="">Gaussian processes, sampling and marginalization</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial6.html" class="">Building a shape model from data</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial7.html" class="">Gaussian processes and kernels</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial8.html" class="">Posterior Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial9.html" class="">Shape completion</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial10.html" class="">ICP for rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial11.html" class="">Model fitting with ICP</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial12.html" class="">Parametric, non-rigid registration</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial13.html" class="">Active Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - The basic framework</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - Fitting a shape model</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="marcelluethi" data-github-repo="scalismo.github.io"><div class="content-wrapper"><section><head>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
        </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<h1 id="model-fitting-using-mcmc---the-basic-framework">Model fitting using MCMC - The basic framework</h1>

<p>In this tutorial we show how Bayesian model fitting using Markov Chain Monte Carlo can be done in Scalismo. To be able
to focus on the main components of the framework instead of technical details, we start in this tutorial with a simple toy example from statistics.
Although the example has nothing to do with shape modelling, the modelling principles and the steps involve to do the inference are
exactly the same. The application to shape modelling is discussed in depth in the next tutorial.</p>

<h3 id="problem-setting">Problem setting</h3>

<p>The problem we are considering here is a simple toy problem from Bayesian statistics: We are trying to fit a (univariate) normal distribution <script type="math/tex">N(\mu, \sigma)</script>,
with unknown mean and unknown standard deviation to a set of data points.
In the following we will denote the unknown parameters by <script type="math/tex">\theta</script>; I.e. <script type="math/tex">\theta = (\mu, \sigma)</script> and the observed data points
by <script type="math/tex">y</script>. In a Bayesian setting, doing inference means that we compute the <em>posterior distribution</em> <script type="math/tex">p(\theta | y)</script>. Formally, the <em>posterior distribution</em> is defined as follows:</p>

<p><script type="math/tex">p(\theta \mid y) = \frac{p(\theta) p(y \mid \theta)}{p(y)}</script>.</p>

<p>The term <script type="math/tex">p(y | \theta)</script> is called the likelihood function, and is
given directly by the problem definition as <script type="math/tex">p(y | \theta) = N(\mu, \sigma)</script>. The term <script type="math/tex">p(\theta)</script> is a prior distribution over the parameters,
which we will define later. The final term involved <script type="math/tex">p(y)</script> is called the marginal likelihood. Formally, it can be defined as <script type="math/tex">p(y) = \int_\theta p(y | \theta) p(\theta) d\theta</script>.
Fortunately, we will never need to compute this quantity.</p>

<p><em>Remark: Computing the posterior distribution of the parameters will also be our goal in a real shape model fitting application.
The only difference is that the parameters <script type="math/tex">\theta</script> are not mean and standard deviation, but the shape model parameters, and the data <script type="math/tex">y</script> are
not simulated numbers, but measurements of the target object, such as a set of landmark points, a surface or even an image.</em></p>

<h3 id="metropolis-hastings-algorithm">Metropolis Hastings Algorithm</h3>

<p>The way we approach such fitting problem in Scalismo is by using the
Metropolis Hastings algorithm. The Metropolis-Hastings algorithm allows us to
draw samples from any distribution, given that the unnormalized distribution can be evaluated point-wise. This requirement is
easy to fulfill for all shape modelling applications.</p>

<p>For setting up the Metropolis-Hastings algorithm, we need two things:</p>
<ol>
  <li>The (unnormalized) target distribution, from which we want to sample. In our case this is the posterior distribution <script type="math/tex">p(\theta \mid y)</script>. In Scalismo
the corresponding class is called the <code class="highlighter-rouge">Distribution Evaluator</code>.</li>
  <li>A proposal distribution <script type="math/tex">Q(\theta' \mid \theta)</script>, which generates for a given sample <script type="math/tex">\theta</script> a new sample <script type="math/tex">\theta'</script>.</li>
</ol>

<p>The Metropolis Hastings algorithm introduces an ingenious scheme for accepting
and rejecting the samples from this proposal distribution, based on their probability under the target density,
such that the resulting sequence of samples is guaranteed to be distributed according to the
target distribution.
In practice, the algorithm works as follows: It uses the proposal generator to perturb a given sample <script type="math/tex">\theta</script> to obtain a new sample <script type="math/tex">\theta'</script>.  Then it checks, using the evaluator, which of the two samples, <script type="math/tex">\theta</script> or <script type="math/tex">\theta'</script> is more likely and
uses this ratio as a basis for rejecting or accepting the new sample.</p>

<h3 id="implementation-in-scalismo">Implementation in Scalismo</h3>

<h5 id="preparation">Preparation</h5>

<p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.sampling.algorithms.MetropolisHastings</span>
<span class="k">import</span> <span class="nn">scalismo.sampling.evaluators.ProductEvaluator</span>
<span class="k">import</span> <span class="nn">scalismo.sampling.loggers.AcceptRejectLogger</span>
<span class="k">import</span> <span class="nn">scalismo.sampling.proposals.MixtureProposal</span>
<span class="k">import</span> <span class="nn">scalismo.sampling.</span><span class="o">{</span><span class="nc">DistributionEvaluator</span><span class="o">,</span> <span class="nc">ProposalGenerator</span><span class="o">,</span> <span class="nc">TransitionProbability</span><span class="o">}</span>

<span class="n">scalismo</span><span class="o">.</span><span class="n">initialize</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">rng</span> <span class="k">=</span> <span class="n">scalismo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="nc">Random</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<p>To test our method, we generate data from a normal distribution <script type="math/tex">N(-5, 17)</script>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">val</span> <span class="n">mu</span> <span class="k">=</span> <span class="o">-</span><span class="mi">5</span>
  <span class="k">val</span> <span class="n">sigma</span> <span class="k">=</span> <span class="mi">17</span>

  <span class="k">val</span> <span class="n">trueDistribution</span> <span class="k">=</span> <span class="n">breeze</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="nc">Gaussian</span><span class="o">(</span><span class="n">mu</span><span class="o">,</span> <span class="n">sigma</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="k">_</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="mi">100</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
    <span class="n">trueDistribution</span><span class="o">.</span><span class="n">draw</span><span class="o">()</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Before we discuss the two main components, the <em>Evaluator</em> and <em>Proposal generator</em> in detail, we first define a class for representing
the parameters <script type="math/tex">\theta = (\mu, \sigma)</script>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Parameters</span><span class="o">(</span><span class="n">mu</span> <span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">sigma</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>
</code></pre></div></div>

<p>We introduce a further class to represent a sample from the chain. A sample is
simply a set of parameters together with a tag, which helps us to keep track later
on, which proposal generator generated the sample:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Sample</span><span class="o">(</span><span class="n">parameters</span> <span class="k">:</span> <span class="kt">Parameters</span><span class="o">,</span> <span class="n">generatedBy</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</code></pre></div></div>

<h4 id="evaluators-modelling-the-target-density">Evaluators: Modelling the target density</h4>

<p>In Scalismo, the target density is represented by classes, which we will refer to
as <em>Evaluators</em>. Any Evaluator is a subclass of the class <code class="highlighter-rouge">DistributionEvalutor</code>,
defined as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">DistributionEvaluator</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="cm">/** log probability/density of sample */</span>
  <span class="k">def</span> <span class="n">logValue</span><span class="o">(</span><span class="n">sample</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We see that the only thing we need to define is the log probability of a sample.</p>

<p>In our case, we will define separate evaluators for the prior distribution <script type="math/tex">p(\theta)</script> and
the likelihood <script type="math/tex">p(y | \theta)</script>.
The evaluator for the likelihood is simple: Assuming a normal model, we define
the normal distribution with the given parameters <script type="math/tex">\theta</script>, and use this model
to evaluate the likelihood of the individual observations.<br />
We assume that the observations are i.i.d. and hence the joint probability
factorises as
<script type="math/tex">p(y |\theta) = p(y_1, \ldots, y_n |\theta) = \prod_{i=1}^n p(y_i |\theta)</script>.
This leads to the following implementation of the liklihood function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">case</span> <span class="k">class</span> <span class="nc">LikelihoodEvaluator</span><span class="o">(</span><span class="n">data</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">DistributionEvaluator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">logValue</span><span class="o">(</span><span class="n">theta</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">likelihood</span> <span class="k">=</span> <span class="n">breeze</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="nc">Gaussian</span><span class="o">(</span>
        <span class="n">theta</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mu</span><span class="o">,</span> <span class="n">theta</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">sigma</span>
      <span class="o">)</span>
      <span class="k">val</span> <span class="n">likelihoods</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">data</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
        <span class="n">likelihood</span><span class="o">.</span><span class="n">logPdf</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
      <span class="o">}</span>
      <span class="n">likelihoods</span><span class="o">.</span><span class="n">sum</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Notice that we work in Scalismo with log probabilities, and hence the product in above formula
becomes a sum.</p>

<p>As a prior, we also use for both parameters a univariate normal distribution.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">PriorEvaluator</span> <span class="k">extends</span> <span class="nc">DistributionEvaluator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">val</span> <span class="n">priorDistMu</span> <span class="k">=</span> <span class="n">breeze</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="nc">Gaussian</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">priorDistSigma</span> <span class="k">=</span> <span class="n">breeze</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="nc">Gaussian</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">logValue</span><span class="o">(</span><span class="n">theta</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">priorDistMu</span><span class="o">.</span><span class="n">logPdf</span><span class="o">(</span><span class="n">theta</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mu</span><span class="o">)</span>
      <span class="o">+</span> <span class="n">priorDistSigma</span><span class="o">.</span><span class="n">logPdf</span><span class="o">(</span><span class="n">theta</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">sigma</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>The target density (i.e. the posterior distribution) can be computed by
taking the product of the prior and the likelihood.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">posteriorEvaluator</span> <span class="k">=</span> <span class="nc">ProductEvaluator</span><span class="o">(</span><span class="nc">PriorEvaluator</span><span class="o">,</span> <span class="nc">LikelihoodEvaluator</span><span class="o">(</span><span class="n">data</span><span class="o">))</span>
</code></pre></div></div>

<p>Note that the posteriorEvaluator represents the unnormalized posterior, as we did
not normalize by the probability of the data <script type="math/tex">p(y)</script>.</p>

<h4 id="the-proposal-generator">The proposal generator</h4>

<p>In Scalismo, a proposal generator is defined by extending the trait
<em>ProposalGenerator</em>, which is defined as follows</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ProposalGenerator</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="cm">/** draw a sample from this proposal distribution, may depend on current state */</span>
  <span class="k">def</span> <span class="n">propose</span><span class="o">(</span><span class="n">current</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In order to be able to use a proposal generator in the Metropolis-Hastings algorithm,
we also need to implement the trait <code class="highlighter-rouge">TransitionProbability</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">TransitionProbability</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">TransitionRatio</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="cm">/** rate of transition from to (log value) */</span>
  <span class="k">def</span> <span class="n">logTransitionProbability</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span>
<span class="o">}</span>
</code></pre></div></div>

<p>To keep things simple, we use here a <em>random walk proposal</em>. This is a proposal
which updates the current state by taking a step of random length in a random direction.
It is defined as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">RandomWalkProposal</span><span class="o">(</span><span class="n">stddevMu</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">stddevSigma</span> <span class="k">:</span> <span class="kt">Double</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">rng</span> <span class="k">:</span> <span class="kt">scalismo.utils.Random</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">ProposalGenerator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span> <span class="k">with</span> <span class="nc">TransitionProbability</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">propose</span><span class="o">(</span><span class="n">sample</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span><span class="k">:</span> <span class="kt">Sample</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">newParameters</span> <span class="k">=</span> <span class="nc">Parameters</span><span class="o">(</span>
        <span class="n">mu</span> <span class="k">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mu</span> <span class="o">+</span> <span class="n">rng</span><span class="o">.</span><span class="n">breezeRandBasis</span><span class="o">.</span><span class="n">gaussian</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">stddevMu</span><span class="o">).</span><span class="n">draw</span><span class="o">(),</span>
        <span class="n">sigma</span> <span class="k">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">sigma</span> <span class="o">+</span> <span class="n">rng</span><span class="o">.</span><span class="n">breezeRandBasis</span><span class="o">.</span><span class="n">gaussian</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">stddevSigma</span><span class="o">).</span><span class="n">draw</span><span class="o">()</span>
      <span class="o">)</span>

      <span class="nc">Sample</span><span class="o">(</span><span class="n">newParameters</span><span class="o">,</span> <span class="n">s</span><span class="s">"randomWalkProposal ($stddevMu, $stddevSigma)"</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">logTransitionProbability</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
    
      <span class="k">val</span> <span class="n">stepDistMu</span> <span class="k">=</span> <span class="n">breeze</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="nc">Gaussian</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">stddevMu</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">stepDistSigma</span> <span class="k">=</span> <span class="n">breeze</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">distributions</span><span class="o">.</span><span class="nc">Gaussian</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">stddevSigma</span><span class="o">)</span>
    
      <span class="k">val</span> <span class="n">residualMu</span> <span class="k">=</span> <span class="n">to</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mu</span> <span class="o">-</span> <span class="n">from</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mu</span>
      <span class="k">val</span> <span class="n">residualSigma</span> <span class="k">=</span> <span class="n">to</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">sigma</span> <span class="o">-</span> <span class="n">from</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">sigma</span>
      <span class="n">stepDistMu</span><span class="o">.</span><span class="n">logPdf</span><span class="o">(</span><span class="n">residualMu</span><span class="o">)</span>  <span class="o">+</span> <span class="n">stepDistMu</span><span class="o">.</span><span class="n">logPdf</span><span class="o">(</span><span class="n">residualSigma</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p><em>Remark: the second constructor argument <code class="highlighter-rouge">implicit rng : scalismo.utils.Random</code>
is used to automatically pass the globally defined random generator object to the
class. If we always use this random generator to generate our random numbers, we can obtain reproducible runs,
by seeding this random generator at the beginning of our program.</em></p>

<p>Let’s define two random walk proposals with different step length:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">smallStepProposal</span> <span class="k">=</span> <span class="nc">RandomWalkProposal</span><span class="o">(</span><span class="mf">3.0</span><span class="o">,</span> <span class="mf">1.0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">largeStepProposal</span> <span class="k">=</span> <span class="nc">RandomWalkProposal</span><span class="o">(</span><span class="mf">9.0</span><span class="o">,</span> <span class="mf">3.0</span><span class="o">)</span>
</code></pre></div></div>

<p>Varying the step length allow us to sometimes take large step, in order to explore the global
landscape, and sometimes smaller steps, to explore a local environment. We can combine these proposal into a
<code class="highlighter-rouge">MixtureProposal</code>, which chooses the individual proposals with a given
probability. Here We choose to take the large step 20% of the time, and the smaller
steps 80% of the time:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">generator</span> <span class="k">=</span> <span class="nc">MixtureProposal</span><span class="o">.</span><span class="n">fromProposalsWithTransition</span><span class="o">[</span><span class="kt">Sample</span><span class="o">](</span>
    <span class="o">(</span><span class="mf">0.8</span><span class="o">,</span> <span class="n">smallStepProposal</span><span class="o">),</span> 
    <span class="o">(</span><span class="mf">0.2</span><span class="o">,</span> <span class="n">largeStepProposal</span><span class="o">)</span>
    <span class="o">)</span>
</code></pre></div></div>

<h4 id="building-the-markov-chain">Building the Markov Chain</h4>

<p>Now that we have all the components set up, we can assemble the Markov Chain.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">chain</span> <span class="k">=</span> <span class="nc">MetropolisHastings</span><span class="o">(</span><span class="n">generator</span><span class="o">,</span> <span class="n">posteriorEvaluator</span><span class="o">)</span>
</code></pre></div></div>

<p>To run the chain, we obtain an iterator,
which we then consume to drive the sampling generation. To obtain the iterator, we need to specify the initial
sample:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">initialSample</span> <span class="k">=</span> <span class="nc">Sample</span><span class="o">(</span><span class="nc">Parameters</span><span class="o">(</span><span class="mf">0.0</span><span class="o">,</span> <span class="mf">10.0</span><span class="o">),</span> <span class="n">generatedBy</span><span class="o">=</span><span class="s">"initial"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">mhIterator</span> <span class="k">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">iterator</span><span class="o">(</span><span class="n">initialSample</span><span class="o">)</span>
</code></pre></div></div>

<p>Our initial parameters might be far away from a high-probability area of our target
density. Therefore it might take a few hundred or even a few thousand iterations before the produced samples
start to follow the required distribution. We therefore have to drop the
samples in this burn-in phase, before we use the samples:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">samples</span> <span class="k">=</span> <span class="n">mhIterator</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="mi">1000</span><span class="o">).</span><span class="n">take</span><span class="o">(</span><span class="mi">5000</span><span class="o">).</span><span class="n">toIndexedSeq</span>  
</code></pre></div></div>

<p>As we have generated synthetic data, we can check if the expected value, computed
from this samples, really corresponds to the parameters from which we sampled
our data:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">estimatedMean</span> <span class="k">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">sample</span> <span class="k">=&gt;</span> <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mu</span><span class="o">).</span><span class="n">sum</span>  <span class="o">/</span> <span class="n">samples</span><span class="o">.</span><span class="n">size</span>
<span class="c1">// estimatedMean: Double = -6.338583284973056
</span>  <span class="n">println</span><span class="o">(</span><span class="s">"estimated mean is "</span> <span class="o">+</span> <span class="n">estimatedMean</span><span class="o">)</span>
<span class="c1">// estimated mean is -6.338583284973056
</span>  <span class="k">val</span> <span class="n">estimatedSigma</span> <span class="k">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">sample</span> <span class="k">=&gt;</span> <span class="n">sample</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">sigma</span><span class="o">).</span><span class="n">sum</span> <span class="o">/</span> <span class="n">samples</span><span class="o">.</span><span class="n">size</span>
<span class="c1">// estimatedSigma: Double = 18.78320037808952
</span>  <span class="n">println</span><span class="o">(</span><span class="s">"estimated sigma is "</span> <span class="o">+</span> <span class="n">estimatedSigma</span><span class="o">)</span>
<span class="c1">// estimated sigma is 18.78320037808952
</span></code></pre></div></div>

<p>In the next tutorial, we see an example of how the exact same  mechanism can be used for
fitting shape models. Before we discuss this, we should, however, spend some time
to discuss how the chain can be debugged in case something goes wrong.
You can safely skip this section and come back to it later if you first want to
see a practical example.</p>

<h4 id="debugging-the-markov-chain">Debugging the markov Chain</h4>

<p>Sometimes a chain does not work as expected. The reason is usually that our proposals
are not suitable for the target distribution. To diagnose the
behaviour of the chain we can introduce a logger. To write a logger, we need to extend
the trait <code class="highlighter-rouge">AcceptRejectLogger</code>, which is defined as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">AcceptRejectLogger</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">accept</span><span class="o">(</span><span class="n">current</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">sample</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">generator</span><span class="k">:</span> <span class="kt">ProposalGenerator</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evaluator</span><span class="k">:</span> <span class="kt">DistributionEvaluator</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span>

  <span class="k">def</span> <span class="n">reject</span><span class="o">(</span><span class="n">current</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">sample</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">generator</span><span class="k">:</span> <span class="kt">ProposalGenerator</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">evaluator</span><span class="k">:</span> <span class="kt">DistributionEvaluator</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The two methods, <code class="highlighter-rouge">accept</code> and <code class="highlighter-rouge">reject</code> are called whenever a sample is
accepted or rejected. We can overwrite these methods to implement our debugging code.</p>

<p>The following, very simple logger counts all the accepted and rejected samples and
computes the acceptance ratio. This acceptance ratio is a simple, but already useful
indicator to diagnose if all proposal generators function as expected.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">Logger</span> <span class="k">extends</span> <span class="nc">AcceptRejectLogger</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">numAccepted</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]()</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">numRejected</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]()</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">accept</span><span class="o">(</span><span class="n">current</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">,</span>
                        <span class="n">sample</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">,</span>
                        <span class="n">generator</span><span class="k">:</span> <span class="kt">ProposalGenerator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">],</span>
                        <span class="n">evaluator</span><span class="k">:</span> <span class="kt">DistributionEvaluator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span>
                       <span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">numAcceptedSoFar</span> <span class="k">=</span> <span class="n">numAccepted</span><span class="o">.</span><span class="n">getOrElseUpdate</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">generatedBy</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">numAccepted</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">generatedBy</span><span class="o">,</span> <span class="n">numAcceptedSoFar</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">reject</span><span class="o">(</span><span class="n">current</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">,</span>
                          <span class="n">sample</span><span class="k">:</span> <span class="kt">Sample</span><span class="o">,</span>
                          <span class="n">generator</span><span class="k">:</span> <span class="kt">ProposalGenerator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">],</span>
                          <span class="n">evaluator</span><span class="k">:</span> <span class="kt">DistributionEvaluator</span><span class="o">[</span><span class="kt">Sample</span><span class="o">]</span>
                         <span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">numRejectedSoFar</span> <span class="k">=</span> <span class="n">numRejected</span><span class="o">.</span><span class="n">getOrElseUpdate</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">generatedBy</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">numRejected</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="n">sample</span><span class="o">.</span><span class="n">generatedBy</span><span class="o">,</span> <span class="n">numRejectedSoFar</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>


    <span class="k">def</span> <span class="n">acceptanceRatios</span><span class="o">()</span> <span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">generatorNames</span> <span class="k">=</span> <span class="n">numRejected</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">toSet</span><span class="o">.</span><span class="n">union</span><span class="o">(</span><span class="n">numAccepted</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">toSet</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">acceptanceRatios</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">generatorName</span> <span class="k">&lt;-</span> <span class="n">generatorNames</span> <span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">total</span> <span class="k">=</span> <span class="o">(</span><span class="n">numAccepted</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">generatorName</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
                     <span class="o">+</span> <span class="n">numRejected</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">generatorName</span><span class="o">,</span> <span class="mi">0</span><span class="o">)).</span><span class="n">toDouble</span>
        <span class="o">(</span><span class="n">generatorName</span><span class="o">,</span> <span class="n">numAccepted</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">generatorName</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span> <span class="o">/</span> <span class="n">total</span><span class="o">)</span>
      <span class="o">}</span>
      <span class="n">acceptanceRatios</span><span class="o">.</span><span class="n">toMap</span>
    <span class="o">}</span>
  <span class="o">}</span>

</code></pre></div></div>

<p>To use the logger, we simply rerun the chain, but pass the logger now as
a second argument to the <code class="highlighter-rouge">iterator</code> method:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">logger</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Logger</span><span class="o">()</span>
<span class="k">val</span> <span class="n">mhIteratorWithLogging</span> <span class="k">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">iterator</span><span class="o">(</span><span class="n">initialSample</span><span class="o">,</span> <span class="n">logger</span><span class="o">)</span>
 <span class="k">val</span> <span class="n">samples2</span> <span class="k">=</span> <span class="n">mhIteratorWithLogging</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="mi">1000</span><span class="o">).</span><span class="n">take</span><span class="o">(</span><span class="mi">3000</span><span class="o">).</span><span class="n">toIndexedSeq</span>  
</code></pre></div></div>

<p>We can now check how often the individual samples got accepted.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">println</span><span class="o">(</span><span class="s">"acceptance ratio is "</span> <span class="o">+</span><span class="n">logger</span><span class="o">.</span><span class="n">acceptanceRatios</span><span class="o">())</span>
<span class="c1">// acceptance ratio is Map(randomWalkProposal (3.0, 1.0) -&gt; 0.49665924276169265, randomWalkProposal (9.0, 3.0) -&gt; 0.15186915887850466)
</span></code></pre></div></div>

<p>We see that the acceptance ratio of the random walk proposal, which takes the
smaller step is quite high, but that the larger step is often rejected. We might
therefore want to reduce this step size slightly, as a proposal that is so often
rejected is not very efficient.</p>

<p>In more complicated applications, this type of debugging is crucial for obtaining
efficient fitting algorithms.</p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalismo.github.io/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script>((window.gitter = {}).chat = {}).options = {
room: 'marcelluethi/scalismo.github.io'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/scalismo.github.io/js/main.js"></script></body></html>
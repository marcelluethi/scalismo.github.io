<html><head><title>scalismo: Rigid alignment</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="University of Basel" /><meta name="description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="image" property="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="og:title" content="scalismo: Rigid alignment" /><meta name="title" property="og:title" content="scalismo: Rigid alignment" /><meta name="og:site_name" content="scalismo" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><link rel="icon" type="image/png" href="/scalismo.github.io/img/favicon.png" /><meta name="twitter:title" content="scalismo: Rigid alignment" /><meta name="twitter:image" content="/scalismo.github.io/img/poster.png" /><meta name="twitter:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/scalismo.github.io/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/scalismo.github.io/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/scalismo.github.io/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/scalismo.github.io/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/scalismo.github.io/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/scalismo.github.io/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/scalismo.github.io/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/scalismo.github.io/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/scalismo.github.io/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/scalismo.github.io/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/scalismo.github.io/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/scalismo.github.io/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/scalismo.github.io/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/scalismo.github.io/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/scalismo.github.io/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/scalismo.github.io/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/scalismo.github.io/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/scalismo.github.io/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/scalismo.github.io/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/scalismo.github.io/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalismo.github.io/highlight/styles/default.css" /><link rel="stylesheet" href="/scalismo.github.io/css/style.css" /><link rel="stylesheet" href="/scalismo.github.io/css/palette.css" /><link rel="stylesheet" href="/scalismo.github.io/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalismo.github.io/" class="brand"><div class="brand-wrapper"><span>scalismo</span></div></a></li> <li><a href="/scalismo.github.io/tutorials/tutorial1.html" class="">Hello Scalismo</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial2.html" class=" active ">Rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial3.html" class="">From meshes to deformation fields</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial4.html" class="">Gaussian processes and Point Distribution Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial5.html" class="">Gaussian processes, sampling and marginalization</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial6.html" class="">Building a shape model from data</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial7.html" class="">Gaussian processes and kernels</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial8.html" class="">Posterior Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial9.html" class="">Shape completion</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial10.html" class="">ICP for rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial11.html" class="">Model fitting with ICP</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial12.html" class="">Parametric, non-rigid registration</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial13.html" class="">Active Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - The basic framework</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - Fitting a shape model</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="marcelluethi" data-github-repo="scalismo.github.io"><div class="content-wrapper"><section><head>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
        </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<h1 id="iterative-closest-points-for-rigid-alignment">Iterative Closest Points for rigid alignment</h1>

<p>The goal in this tutorial is to derive an implementation of the classical Iterative Closest Points (ICP) algorithm
in the context of rigid alignment of shapes.</p>

<h5 id="related-resources">Related resources</h5>

<p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling">online course</a> may provide
some helpful context for this tutorial:</p>

<ul>
  <li>Superimposing shapes <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250330">(Article)</a></li>
  <li>Model-fitting and correspondence <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250371">(Video)</a></li>
</ul>

<h5 id="preparation">Preparation</h5>

<p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.geometry._</span>
<span class="k">import</span> <span class="nn">scalismo.common._</span>
<span class="k">import</span> <span class="nn">scalismo.ui.api._</span>
<span class="k">import</span> <span class="nn">scalismo.mesh._</span>
<span class="k">import</span> <span class="nn">scalismo.registration.LandmarkRegistration</span>
<span class="k">import</span> <span class="nn">scalismo.io.</span><span class="o">{</span><span class="nc">MeshIO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scalismo.numerics.UniformMeshSampler3D</span>
<span class="k">import</span> <span class="nn">breeze.linalg.</span><span class="o">{</span><span class="nc">DenseMatrix</span><span class="o">,</span> <span class="nc">DenseVector</span><span class="o">}</span>

<span class="n">scalismo</span><span class="o">.</span><span class="n">initialize</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">rng</span> <span class="k">=</span> <span class="n">scalismo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="nc">Random</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ui</span> <span class="k">=</span> <span class="nc">ScalismoUI</span><span class="o">()</span>
</code></pre></div></div>

<h2 id="automatic-rigid-alignment">Automatic rigid alignment</h2>

<p>We start by loading and visualizing two meshes</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">mesh1</span> <span class="k">=</span> <span class="nc">MeshIO</span><span class="o">.</span><span class="n">readMesh</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/Paola.stl"</span><span class="o">)).</span><span class="n">get</span>
<span class="k">val</span> <span class="n">group1</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"Dataset 1"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">mesh1View</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">group1</span><span class="o">,</span> <span class="n">mesh1</span><span class="o">,</span> <span class="s">"mesh1"</span><span class="o">)</span>

<span class="k">val</span> <span class="n">mesh2</span> <span class="k">=</span> <span class="nc">MeshIO</span><span class="o">.</span><span class="n">readMesh</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/323.stl"</span><span class="o">)).</span><span class="n">get</span>
<span class="k">val</span> <span class="n">group2</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"Dataset 2"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">mesh2View</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">group2</span><span class="o">,</span> <span class="n">mesh2</span><span class="o">,</span> <span class="s">"mesh2"</span><span class="o">)</span>
<span class="n">mesh2View</span><span class="o">.</span><span class="n">color</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">awt</span><span class="o">.</span><span class="nc">Color</span><span class="o">.</span><span class="nc">RED</span>
</code></pre></div></div>

<p>As you can see here, the meshes are not aligned. As in previous tutorials, we could identify corresponding points
to align the meshes. The downside is, that this requires some manual intervention.
In this tutorial we will instead use the Iterative Closest Point (ICP) method to perform this rigid alignment step <strong>automatically</strong>.</p>

<h3 id="candidate-correspondences">Candidate correspondences</h3>

<p>We have seen before that finding the best rigid transformation when given correct correspondences has a closed-form
solution. The problem we are facing here is that we do not have these correspondences. The idea of the ICP algorithm is,
that we can approximate the correspondences, by simply assuming that the corresponding point is always the closest point on
the mesh.</p>

<p>Let’s select a few points from the mesh.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">ptIds</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">mesh1</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">numberOfPoints</span> <span class="n">by</span> <span class="mi">50</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">PointId</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">group1</span><span class="o">,</span> <span class="n">ptIds</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">id</span> <span class="k">=&gt;</span> <span class="n">mesh1</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)),</span> <span class="s">"selected"</span><span class="o">)</span>
</code></pre></div></div>

<p>The exact number of points is not important. It is only important that we select points, which are approximately
uniformly distributed over the surface.</p>

<p>In the next step, we find the corresponding points in the other mesh:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">attributeCorrespondences</span><span class="o">(</span><span class="n">movingMesh</span><span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span> <span class="n">ptIds</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">PointId</span><span class="o">])</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">ptIds</span><span class="o">.</span><span class="n">map</span><span class="o">{</span> <span class="n">id</span> <span class="k">:</span> <span class="kt">PointId</span> <span class="o">=&gt;</span> 
    <span class="k">val</span> <span class="n">pt</span> <span class="k">=</span> <span class="n">movingMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">closestPointOnMesh2</span> <span class="k">=</span> <span class="n">mesh2</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">findClosestPoint</span><span class="o">(</span><span class="n">pt</span><span class="o">).</span><span class="n">point</span>
    <span class="o">(</span><span class="n">pt</span><span class="o">,</span> <span class="n">closestPointOnMesh2</span><span class="o">)</span>
  <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p>Note that we used here not <code class="highlighter-rouge">mesh1</code> directly, but passed the mesh from which we find the closest points as an argument,
which we called the <code class="highlighter-rouge">MovingMesh</code>. The reason is, that this will later be iteratively transformed to come closer to our target mesh <code class="highlighter-rouge">mesh2</code>.</p>

<p>Let us now visualize the the chosen correspondences:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">correspondences</span> <span class="k">=</span> <span class="n">attributeCorrespondences</span><span class="o">(</span><span class="n">mesh1</span><span class="o">,</span> <span class="n">ptIds</span><span class="o">)</span>
<span class="k">val</span> <span class="n">targetPoints</span> <span class="k">=</span> <span class="n">correspondences</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">pointPair</span> <span class="k">=&gt;</span> <span class="n">pointPair</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">group2</span><span class="o">,</span> <span class="n">targetPoints</span><span class="o">.</span><span class="n">toIndexedSeq</span><span class="o">,</span> <span class="s">"correspondences"</span><span class="o">)</span>
</code></pre></div></div>

<p>As expected, the obtained correspondences are clearly not good, as they tend to focus on only one side of the target face.
Nevertheless, we can apply Procrustes analysis based on these correspondences and
retrieve a rigid transformation, which brings us closer to the target.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">rigidTrans</span> <span class="k">=</span>  <span class="nc">LandmarkRegistration</span><span class="o">.</span><span class="n">rigid3DLandmarkRegistration</span><span class="o">(</span><span class="n">correspondences</span><span class="o">,</span> <span class="n">center</span> <span class="k">=</span> <span class="nc">Point3D</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>
<span class="k">val</span> <span class="n">transformed</span> <span class="k">=</span> <span class="n">mesh1</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span><span class="n">rigidTrans</span><span class="o">)</span> 
<span class="k">val</span> <span class="n">alignedMeshView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">group1</span><span class="o">,</span> <span class="n">transformed</span><span class="o">,</span> <span class="s">"aligned?"</span><span class="o">)</span>
<span class="n">alignedMeshView</span><span class="o">.</span><span class="n">color</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">awt</span><span class="o">.</span><span class="nc">Color</span><span class="o">.</span><span class="nc">GREEN</span>
</code></pre></div></div>

<p><strong>Well, no surprise here.</strong> Given the poor quality of the candidate correspondences, we obtained a poor rigid alignment.
This said, when considering where we started from, that is the original position, we did get closer to the target.</p>

<p>The second important idea of the ICP algorithm comes is now to <strong>iterate</strong> this steps in the hope that it will converge.
Let’s try it out:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">newCorrespondences</span> <span class="k">=</span> <span class="n">attributeCorrespondences</span><span class="o">(</span><span class="n">transformed</span><span class="o">,</span> <span class="n">ptIds</span><span class="o">)</span>
<span class="k">val</span> <span class="n">newClosestPoints</span> <span class="k">=</span> <span class="n">newCorrespondences</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">pointPair</span> <span class="k">=&gt;</span> <span class="n">pointPair</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">group2</span><span class="o">,</span> <span class="n">newClosestPoints</span><span class="o">.</span><span class="n">toIndexedSeq</span><span class="o">,</span> <span class="s">"newCandidateCorr"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">newRigidTransformation</span> <span class="k">=</span> 
    <span class="nc">LandmarkRegistration</span><span class="o">.</span><span class="n">rigid3DLandmarkRegistration</span><span class="o">(</span><span class="n">newCorrespondences</span><span class="o">,</span> <span class="n">center</span> <span class="k">=</span> <span class="nc">Point3D</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>
<span class="k">val</span> <span class="n">newTransformed</span> <span class="k">=</span> <span class="n">transformed</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span><span class="n">newRigidTransformation</span><span class="o">)</span> 
<span class="k">val</span> <span class="n">alignedMeshView2</span> <span class="k">=</span>  <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">group2</span><span class="o">,</span> <span class="n">newTransformed</span><span class="o">,</span> <span class="s">"aligned??"</span><span class="o">)</span>
<span class="n">alignedMeshView2</span><span class="o">.</span><span class="n">color</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">awt</span><span class="o">.</span><span class="nc">Color</span><span class="o">.</span><span class="nc">BLUE</span>
</code></pre></div></div>

<p>As you can see, the candidate correspondences are still clearly wrong,
but start to be more spread around the target face.
Also the resulting rigid transformation seems to bring our mesh a bit closer to the target.</p>

<p>Finally, we change our implementation such that we can perform an arbitrary number of iterations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">ICPRigidAlign</span><span class="o">(</span><span class="n">movingMesh</span><span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span> <span class="n">ptIds</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">PointId</span><span class="o">],</span> <span class="n">numberOfIterations</span> <span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">numberOfIterations</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">movingMesh</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">correspondences</span> <span class="k">=</span> <span class="n">attributeCorrespondences</span><span class="o">(</span><span class="n">movingMesh</span><span class="o">,</span> <span class="n">ptIds</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">transform</span> <span class="k">=</span> <span class="nc">LandmarkRegistration</span><span class="o">.</span><span class="n">rigid3DLandmarkRegistration</span><span class="o">(</span><span class="n">correspondences</span><span class="o">,</span> <span class="n">center</span> <span class="k">=</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>
    <span class="k">val</span> <span class="n">transformed</span> <span class="k">=</span> <span class="n">movingMesh</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span><span class="n">transform</span><span class="o">)</span> 
        
    <span class="nc">ICPRigidAlign</span><span class="o">(</span><span class="n">transformed</span><span class="o">,</span> <span class="n">ptIds</span><span class="o">,</span> <span class="n">numberOfIterations</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s now run it with 150 iterations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">val</span> <span class="n">rigidfit</span> <span class="k">=</span> <span class="nc">ICPRigidAlign</span><span class="o">(</span><span class="n">mesh1</span><span class="o">,</span> <span class="n">ptIds</span><span class="o">,</span> <span class="mi">150</span><span class="o">)</span>
<span class="k">val</span> <span class="n">rigidFitView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">group1</span><span class="o">,</span> <span class="n">rigidfit</span><span class="o">,</span> <span class="s">"ICP_rigid_fit"</span><span class="o">)</span>
<span class="n">rigidFitView</span><span class="o">.</span><span class="n">color</span> <span class="k">=</span> <span class="n">java</span><span class="o">.</span><span class="n">awt</span><span class="o">.</span><span class="nc">Color</span><span class="o">.</span><span class="nc">YELLOW</span>
</code></pre></div></div>

<p>As you can see here, the quality of the candidate correspondences did indeed result in a proper
<strong>automatic</strong> rigid alignment of Paola to the target. One should not forget, however, that the ICP method is
very sensitive to the initial position, and might easily get stuck in a local minimum.</p>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalismo.github.io/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script>((window.gitter = {}).chat = {}).options = {
room: 'marcelluethi/scalismo.github.io'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/scalismo.github.io/js/main.js"></script></body></html>
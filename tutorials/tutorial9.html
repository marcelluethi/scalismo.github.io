<html><head><title>scalismo: Rigid alignment</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="University of Basel" /><meta name="description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="image" property="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="og:title" content="scalismo: Rigid alignment" /><meta name="title" property="og:title" content="scalismo: Rigid alignment" /><meta name="og:site_name" content="scalismo" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><link rel="icon" type="image/png" href="/scalismo.github.io/img/favicon.png" /><meta name="twitter:title" content="scalismo: Rigid alignment" /><meta name="twitter:image" content="/scalismo.github.io/img/poster.png" /><meta name="twitter:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/scalismo.github.io/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/scalismo.github.io/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/scalismo.github.io/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/scalismo.github.io/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/scalismo.github.io/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/scalismo.github.io/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/scalismo.github.io/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/scalismo.github.io/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/scalismo.github.io/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/scalismo.github.io/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/scalismo.github.io/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/scalismo.github.io/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/scalismo.github.io/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/scalismo.github.io/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/scalismo.github.io/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/scalismo.github.io/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/scalismo.github.io/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/scalismo.github.io/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/scalismo.github.io/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/scalismo.github.io/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalismo.github.io/highlight/styles/default.css" /><link rel="stylesheet" href="/scalismo.github.io/css/style.css" /><link rel="stylesheet" href="/scalismo.github.io/css/palette.css" /><link rel="stylesheet" href="/scalismo.github.io/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalismo.github.io/" class="brand"><div class="brand-wrapper"><span>scalismo</span></div></a></li> <li><a href="/scalismo.github.io/tutorials/tutorial1.html" class="">Hello Scalismo</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial2.html" class=" active ">Rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial3.html" class="">From meshes to deformation fields</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial4.html" class="">Gaussian processes and Point Distribution Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial5.html" class="">Gaussian processes, sampling and marginalization</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial6.html" class="">Building a shape model from data</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial7.html" class="">Gaussian processes and kernels</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial8.html" class="">Posterior Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial9.html" class="">Shape completion</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial10.html" class="">ICP for rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial11.html" class="">Model fitting with ICP</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial12.html" class="">Parametric, non-rigid registration</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial13.html" class="">Active Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - The basic framework</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - Fitting a shape model</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="marcelluethi" data-github-repo="scalismo.github.io"><div class="content-wrapper"><section><head>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
        </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<h1 id="shape-completion-using-gaussian-process-regression">Shape completion using Gaussian process regression</h1>

<p>In this tutorial we will show how GP regression can be used to predict missing parts of a shape.</p>

<h5 id="preparation">Preparation</h5>

<p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.geometry._</span>
<span class="k">import</span> <span class="nn">scalismo.common._</span>
<span class="k">import</span> <span class="nn">scalismo.ui.api._</span>
<span class="k">import</span> <span class="nn">scalismo.mesh._</span>
<span class="k">import</span> <span class="nn">scalismo.io.</span><span class="o">{</span><span class="nc">StatisticalModelIO</span><span class="o">,</span> <span class="nc">MeshIO</span><span class="o">,</span> <span class="nc">LandmarkIO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scalismo.statisticalmodel._</span>
<span class="k">import</span> <span class="nn">scalismo.numerics.UniformMeshSampler3D</span>
<span class="k">import</span> <span class="nn">scalismo.kernels._</span>
<span class="k">import</span> <span class="nn">breeze.linalg.</span><span class="o">{</span><span class="nc">DenseMatrix</span><span class="o">,</span> <span class="nc">DenseVector</span><span class="o">}</span>

<span class="n">scalismo</span><span class="o">.</span><span class="n">initialize</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">rng</span> <span class="k">=</span> <span class="n">scalismo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="nc">Random</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ui</span> <span class="k">=</span> <span class="nc">ScalismoUI</span><span class="o">()</span>
</code></pre></div></div>

<p>We also load a dataset that we want to reconstruct. In this case, it is a face without nose:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">noseless</span> <span class="k">=</span> <span class="nc">MeshIO</span><span class="o">.</span><span class="n">readMesh</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/noseless.stl"</span><span class="o">)).</span><span class="n">get</span>

<span class="k">val</span> <span class="n">targetGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"target"</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">targetGroup</span><span class="o">,</span> <span class="n">noseless</span><span class="o">,</span><span class="s">"noseless"</span><span class="o">)</span>
</code></pre></div></div>

<p>Finally, we also load the face model.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">smallModel</span> <span class="k">=</span> <span class="nc">StatisticalModelIO</span><span class="o">.</span><span class="n">readStatisticalMeshModel</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/model.h5"</span><span class="o">)).</span><span class="n">get</span> 
</code></pre></div></div>

<h2 id="enlarging-the-flexibility-of-a-shape-model">Enlarging the flexibility of a shape model</h2>

<p>The model, which we just loaded, was built from only a small dataset. Therefore, the chances that it manages to
reconstruct the missing nose properly are rather slim.</p>

<p>To increase the shape variability of the model, we add smooth some additional smooth shape deformations,
modelled by a GP with symmetric Gaussian kernel. The code should be familiar from the previous tutorials.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">scalarValuedKernel</span> <span class="k">=</span> <span class="nc">GaussianKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">](</span><span class="mi">70</span><span class="o">)</span> <span class="o">*</span> <span class="mf">10.0</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">XmirroredKernel</span><span class="o">(</span><span class="n">kernel</span> <span class="k">:</span> <span class="kt">PDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">PDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">domain</span> <span class="k">=</span> <span class="nc">RealSpace</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">k</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">=</span> <span class="n">kernel</span><span class="o">(</span><span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1f</span> <span class="o">,</span><span class="n">x</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">x</span><span class="o">(</span><span class="mi">2</span><span class="o">)),</span> <span class="n">y</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">symmetrizeKernel</span><span class="o">(</span><span class="n">kernel</span> <span class="k">:</span> <span class="kt">PDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">:</span> <span class="kt">MatrixValuedPDKernel</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">xmirrored</span> <span class="k">=</span> <span class="nc">XmirroredKernel</span><span class="o">(</span><span class="n">kernel</span><span class="o">)</span>
   <span class="k">val</span> <span class="n">k1</span> <span class="k">=</span> <span class="nc">DiagonalKernel</span><span class="o">(</span><span class="n">kernel</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
   <span class="k">val</span> <span class="n">k2</span> <span class="k">=</span> <span class="nc">DiagonalKernel</span><span class="o">(</span><span class="n">xmirrored</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1f</span><span class="o">,</span> <span class="n">xmirrored</span><span class="o">,</span> <span class="n">xmirrored</span><span class="o">)</span>  
   <span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">gp</span> <span class="k">=</span> <span class="nc">GaussianProcess</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]](</span><span class="n">symmetrizeKernel</span><span class="o">(</span><span class="n">scalarValuedKernel</span><span class="o">))</span>
<span class="k">val</span> <span class="n">lowrankGP</span> <span class="k">=</span> <span class="nc">LowRankGaussianProcess</span><span class="o">.</span><span class="n">approximateGPCholesky</span><span class="o">(</span>
    <span class="n">smallModel</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">,</span>
    <span class="n">gp</span><span class="o">,</span> 
    <span class="n">relativeTolerance</span> <span class="k">=</span> <span class="mf">0.01</span><span class="o">,</span> 
    <span class="n">interpolator</span> <span class="k">=</span> <span class="nc">NearestNeighborInterpolator</span><span class="o">())</span>
    
<span class="k">val</span> <span class="n">model</span> <span class="k">=</span> <span class="nc">StatisticalMeshModel</span><span class="o">.</span><span class="n">augmentModel</span><span class="o">(</span><span class="n">smallModel</span><span class="o">,</span> <span class="n">lowrankGP</span><span class="o">)</span>

<span class="k">val</span> <span class="n">modelGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"face model"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">ssmView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">model</span><span class="o">,</span> <span class="s">"model"</span><span class="o">)</span>
</code></pre></div></div>

<p>The new model should now contain much more flexibility, while still preserving the typical face-specific deformations.</p>

<p><em>Note: This step here is mainly motivated by the fact that we only have 10 face examples available to build the model. However,
even if sufficient data is available, it might still be a good idea to slighly enlarge the flexibility of a model
before attempting a reconstruction of missing parts. It gives the model some extra slack to account for
bias in the data and explain minor shape variations, which have not been prominent in the dataset</em>.</p>

<p>Equipped with our new model, we will perform the reconstruction in three steps:</p>

<ol>
  <li>We fit the face model to the given partial face using Gaussian process regression.</li>
  <li>We restrict the model to the nose part by marginalizing and select a suitable nose shape.</li>
  <li>We choose a suitable nose from the model</li>
</ol>

<p>As we saw previously, to perform GP regression we need observations of the deformation vectors at some points.
We will discussed in <a href="./tutorial10.html">Tutorial 10</a> how such observations can be obtained fully automatically.
Here, we have done this already in a separate step and saved 200 corresponding points as landmarks, which we will now load and visualize:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">referenceLandmarks</span> <span class="k">=</span> <span class="nc">LandmarkIO</span><span class="o">.</span><span class="n">readLandmarksJson</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">](</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/modelLandmarks.json"</span><span class="o">)).</span><span class="n">get</span>
<span class="k">val</span> <span class="n">referencePoints</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="n">referenceLandmarks</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">lm</span> <span class="k">=&gt;</span> <span class="n">lm</span><span class="o">.</span><span class="n">point</span><span class="o">)</span>
<span class="k">val</span> <span class="n">referenceLandmarkViews</span> <span class="k">=</span> <span class="n">referenceLandmarks</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">lm</span> <span class="k">=&gt;</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">lm</span><span class="o">,</span> <span class="n">s</span><span class="s">"lm-${lm.id}"</span><span class="o">))</span>


<span class="k">val</span> <span class="n">noselessLandmarks</span> <span class="k">=</span> <span class="nc">LandmarkIO</span><span class="o">.</span><span class="n">readLandmarksJson</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">](</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/noselessLandmarks.json"</span><span class="o">)).</span><span class="n">get</span>
<span class="k">val</span> <span class="n">noselessPoints</span> <span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="n">noselessLandmarks</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">lm</span> <span class="k">=&gt;</span> <span class="n">lm</span><span class="o">.</span><span class="n">point</span><span class="o">)</span>
<span class="k">val</span> <span class="n">noselessLandmarkViews</span> <span class="k">=</span> <span class="n">noselessLandmarks</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">lm</span> <span class="k">=&gt;</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">targetGroup</span><span class="o">,</span> <span class="n">lm</span><span class="o">,</span> <span class="n">s</span><span class="s">"lm-${lm.id}"</span><span class="o">))</span>
</code></pre></div></div>

<p>These correspondences define how each selected point of the
model should be deformed to its corresponding point on the target mesh.
In other words, we <strong>observed</strong> a few deformation vectors at
the selected model points. We use these deformation vectors and build
a deformation field:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">domain</span> <span class="k">=</span> <span class="nc">UnstructuredPointsDomain</span><span class="o">(</span><span class="n">referencePoints</span><span class="o">.</span><span class="n">toIndexedSeq</span><span class="o">)</span>
<span class="k">val</span> <span class="n">deformations</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">referencePoints</span><span class="o">.</span><span class="n">size</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">noselessPoints</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">-</span> <span class="n">referencePoints</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">)</span>
<span class="k">val</span> <span class="n">defField</span> <span class="k">=</span> <span class="nc">DiscreteField</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">UnstructuredPointsDomain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]](</span><span class="n">domain</span><span class="o">,</span> <span class="n">deformations</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">defField</span><span class="o">,</span> <span class="s">"partial_Field"</span><span class="o">)</span>
</code></pre></div></div>

<p>We can now perform GP regression and retrieve the rest of the deformations fitting our observations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">littleNoise</span> <span class="k">=</span> <span class="nc">MultivariateNormalDistribution</span><span class="o">(</span><span class="nc">DenseVector</span><span class="o">.</span><span class="n">zeros</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">),</span> <span class="nc">DenseMatrix</span><span class="o">.</span><span class="n">eye</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">)</span>

<span class="k">val</span> <span class="n">regressionData</span> <span class="k">=</span> <span class="k">for</span> <span class="o">((</span><span class="n">refPoint</span><span class="o">,</span> <span class="n">noselessPoint</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">referencePoints</span> <span class="n">zip</span> <span class="n">noselessPoints</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">refPointId</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">findClosestPoint</span><span class="o">(</span><span class="n">refPoint</span><span class="o">).</span><span class="n">id</span> 
    <span class="o">(</span><span class="n">refPointId</span><span class="o">,</span> <span class="n">noselessPoint</span><span class="o">,</span> <span class="n">littleNoise</span><span class="o">)</span> 
<span class="o">}</span>

<span class="k">val</span> <span class="n">posterior</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">posterior</span><span class="o">(</span><span class="n">regressionData</span><span class="o">.</span><span class="n">toIndexedSeq</span><span class="o">)</span>

<span class="k">val</span> <span class="n">posteriorGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"posterior-model"</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">posteriorGroup</span><span class="o">,</span> <span class="n">posterior</span><span class="o">,</span> <span class="s">"posterior"</span><span class="o">)</span>
</code></pre></div></div>

<p>With this posterior model, we get a normal distribution of faces satisfying our observations by having the selected characteristic points at the indicated positions.</p>

<p>Finally, as we are interested in the nose region only, we marginalize our posterior to obtain a posterior nose model as we did in a previous tutorial:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">val</span> <span class="n">nosePtIDs</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">pointIds</span><span class="o">.</span><span class="n">filter</span> <span class="o">{</span> <span class="n">id</span> <span class="k">=&gt;</span>
  <span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-</span> <span class="n">model</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="nc">PointId</span><span class="o">(</span><span class="mi">8152</span><span class="o">))).</span><span class="n">norm</span> <span class="o">&lt;=</span> <span class="mi">42</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">posteriorNoseModel</span> <span class="k">=</span> <span class="n">posterior</span><span class="o">.</span><span class="n">marginal</span><span class="o">(</span><span class="n">nosePtIDs</span><span class="o">.</span><span class="n">toIndexedSeq</span><span class="o">)</span>

<span class="k">val</span> <span class="n">posteriorNoseGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"posterior-nose-model"</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">posteriorNoseGroup</span><span class="o">,</span> <span class="n">posteriorNoseModel</span><span class="o">,</span> <span class="s">"posteriorNoseModel"</span><span class="o">)</span>
</code></pre></div></div>

<p>We now have a probability distribution over fitting nose shapes. Our last
task is to select one nose as a reconstruction.  A simple and often
reasonable choice is to use the mean of this model, as this is the reconstruction
with the highest probability under the model.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">bestReconstruction</span> <span class="k">=</span> <span class="n">posteriorNoseModel</span><span class="o">.</span><span class="n">mean</span>
</code></pre></div></div>

<p>Having a full posterior distribution
over fitting nose shapes gives us, however, much more freedom in choosing a
reconstruction. By introducing a utility function, which models the utility of each reconstruction for a given task,
we can use this distribution as the basis for decision making by minimizing the expected posterior loss.</p>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalismo.github.io/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script>((window.gitter = {}).chat = {}).options = {
room: 'marcelluethi/scalismo.github.io'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/scalismo.github.io/js/main.js"></script></body></html>
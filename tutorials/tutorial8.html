<html><head><title>scalismo: Rigid alignment</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="University of Basel" /><meta name="description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="image" property="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="og:title" content="scalismo: Rigid alignment" /><meta name="title" property="og:title" content="scalismo: Rigid alignment" /><meta name="og:site_name" content="scalismo" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><link rel="icon" type="image/png" href="/scalismo.github.io/img/favicon.png" /><meta name="twitter:title" content="scalismo: Rigid alignment" /><meta name="twitter:image" content="/scalismo.github.io/img/poster.png" /><meta name="twitter:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/scalismo.github.io/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/scalismo.github.io/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/scalismo.github.io/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/scalismo.github.io/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/scalismo.github.io/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/scalismo.github.io/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/scalismo.github.io/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/scalismo.github.io/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/scalismo.github.io/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/scalismo.github.io/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/scalismo.github.io/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/scalismo.github.io/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/scalismo.github.io/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/scalismo.github.io/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/scalismo.github.io/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/scalismo.github.io/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/scalismo.github.io/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/scalismo.github.io/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/scalismo.github.io/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/scalismo.github.io/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalismo.github.io/highlight/styles/default.css" /><link rel="stylesheet" href="/scalismo.github.io/css/style.css" /><link rel="stylesheet" href="/scalismo.github.io/css/palette.css" /><link rel="stylesheet" href="/scalismo.github.io/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalismo.github.io/" class="brand"><div class="brand-wrapper"><span>scalismo</span></div></a></li> <li><a href="/scalismo.github.io/tutorials/tutorial1.html" class="">Hello Scalismo</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial2.html" class=" active ">Rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial3.html" class="">From meshes to deformation fields</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial4.html" class="">Gaussian processes and Point Distribution Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial5.html" class="">Gaussian processes, sampling and marginalization</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial6.html" class="">Building a shape model from data</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial7.html" class="">Gaussian processes and kernels</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial8.html" class="">Posterior Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial9.html" class="">Shape completion</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial10.html" class="">ICP for rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial11.html" class="">Model fitting with ICP</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial12.html" class="">Parametric, non-rigid registration</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial13.html" class="">Active Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - The basic framework</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - Fitting a shape model</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="marcelluethi" data-github-repo="scalismo.github.io"><div class="content-wrapper"><section><head>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
        </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<h1 id="posterior-shape-models">Posterior Shape Models</h1>

<p>In this tutorial we will use Gaussian processes for regression tasks and experiment with the concept of posterior shape models.
This will form the basics for the next tutorial, where we will see how these tools can be applied to construct a
reconstruction of partial shapes.</p>

<h5 id="related-resources">Related resources</h5>

<p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling">online course</a> may provide
some helpful context for this tutorial:</p>

<ul>
  <li>The regression problem <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250360">(Article)</a></li>
  <li>Gaussian process regression <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250361">(Video)</a></li>
  <li>Posterior models for different kernels <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250362">(Article)</a></li>
</ul>

<h5 id="preparation">Preparation</h5>

<p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.geometry._</span>
<span class="k">import</span> <span class="nn">scalismo.common._</span>
<span class="k">import</span> <span class="nn">scalismo.ui.api._</span>
<span class="k">import</span> <span class="nn">scalismo.mesh._</span>
<span class="k">import</span> <span class="nn">scalismo.io.</span><span class="o">{</span><span class="nc">StatisticalModelIO</span><span class="o">,</span> <span class="nc">MeshIO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scalismo.statisticalmodel._</span>
<span class="k">import</span> <span class="nn">scalismo.numerics.UniformMeshSampler3D</span>
<span class="k">import</span> <span class="nn">scalismo.kernels._</span>
<span class="k">import</span> <span class="nn">breeze.linalg.</span><span class="o">{</span><span class="nc">DenseMatrix</span><span class="o">,</span> <span class="nc">DenseVector</span><span class="o">}</span>

<span class="n">scalismo</span><span class="o">.</span><span class="n">initialize</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">rng</span> <span class="k">=</span> <span class="n">scalismo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="nc">Random</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ui</span> <span class="k">=</span> <span class="nc">ScalismoUI</span><span class="o">()</span>
</code></pre></div></div>

<p>We also load and visualize the face model:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">model</span> <span class="k">=</span> <span class="nc">StatisticalModelIO</span><span class="o">.</span><span class="n">readStatisticalMeshModel</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/bfm.h5"</span><span class="o">)).</span><span class="n">get</span>

<span class="k">val</span> <span class="n">modelGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"modelGroup"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">ssmView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">model</span><span class="o">,</span> <span class="s">"model"</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="fitting-observed-data-using-gaussian-process-regression">Fitting observed data using Gaussian process regression</h2>

<p>The reason we build statistical models is that we want to use them
for explaining data. More precisely, given some observed data, we fit the model
to the data and get as a result a distribution over the model parameters.
In our case, the model is a Gaussian process model of shape deformations, and the data are observed shape deformations; I.e. deformation vectors from the reference surface.</p>

<p>To illustrate this process, we simulate some data. We generate<br />
a deformation vector at the tip of the nose, which corresponds ot a really long
nose:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">idNoseTip</span> <span class="k">=</span> <span class="nc">PointId</span><span class="o">(</span><span class="mi">8156</span><span class="o">)</span>
<span class="k">val</span> <span class="n">noseTipReference</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">idNoseTip</span><span class="o">)</span>
<span class="k">val</span> <span class="n">noseTipMean</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">mean</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">idNoseTip</span><span class="o">)</span>
<span class="k">val</span> <span class="n">noseTipDeformation</span> <span class="k">=</span> <span class="o">(</span><span class="n">noseTipMean</span> <span class="o">-</span> <span class="n">noseTipReference</span><span class="o">)</span> <span class="o">*</span> <span class="mf">2.0</span>
</code></pre></div></div>

<p>To visualize this deformation, we need to define a <code class="highlighter-rouge">DiscreteField</code>, which can then be passed to the show
method of our <code class="highlighter-rouge">ui</code> object.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">noseTipDomain</span> <span class="k">=</span> <span class="nc">UnstructuredPointsDomain</span><span class="o">(</span><span class="nc">IndexedSeq</span><span class="o">(</span><span class="n">noseTipReference</span><span class="o">))</span>
<span class="k">val</span> <span class="n">noseTipDeformationAsSeq</span> <span class="k">=</span> <span class="nc">IndexedSeq</span><span class="o">(</span><span class="n">noseTipDeformation</span><span class="o">)</span>
<span class="k">val</span> <span class="n">noseTipDeformationField</span> <span class="k">=</span> <span class="nc">DiscreteField</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">UnstructuredPointsDomain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]](</span><span class="n">noseTipDomain</span><span class="o">,</span> <span class="n">noseTipDeformationAsSeq</span><span class="o">)</span>

<span class="k">val</span> <span class="n">observationGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"observation"</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">observationGroup</span><span class="o">,</span> <span class="n">noseTipDeformationField</span><span class="o">,</span> <span class="s">"noseTip"</span><span class="o">)</span>
</code></pre></div></div>

<p>In the next step we set up the regression. The Gaussian process model assumes that the deformation
is observed only up to some uncertainty,
which can be modelled using a normal distribution.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">noise</span> <span class="k">=</span> <span class="nc">MultivariateNormalDistribution</span><span class="o">(</span><span class="nc">DenseVector</span><span class="o">.</span><span class="n">zeros</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">),</span> <span class="nc">DenseMatrix</span><span class="o">.</span><span class="n">eye</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">))</span>
</code></pre></div></div>

<p>In Scalismo, the data for the regression is specified by a sequence of triples, consisting of the point of the reference, the
corresponding deformation vector, as well as the noise at that point:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">regressionData</span> <span class="k">=</span> <span class="nc">IndexedSeq</span><span class="o">((</span><span class="n">noseTipReference</span><span class="o">,</span> <span class="n">noseTipDeformation</span><span class="o">,</span> <span class="n">noise</span><span class="o">))</span>
</code></pre></div></div>

<p>We can now obtain the regression result by feeding this data to the method <code class="highlighter-rouge">regression</code> of the <code class="highlighter-rouge">GaussianProcess</code> object:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">gp</span> <span class="k">:</span> <span class="kt">LowRankGaussianProcess</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">interpolate</span><span class="o">(</span><span class="nc">NearestNeighborInterpolator</span><span class="o">())</span>
<span class="k">val</span> <span class="n">posteriorGP</span> <span class="k">:</span> <span class="kt">LowRankGaussianProcess</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">LowRankGaussianProcess</span><span class="o">.</span><span class="n">regression</span><span class="o">(</span><span class="n">gp</span><span class="o">,</span> <span class="n">regressionData</span><span class="o">)</span>
</code></pre></div></div>

<p>Note that the result of the regression is again a Gaussian process, over the same domain as the original process. We call this the <em>posterior process</em>.
This construction is very important in Scalismo. Therefore, we have a convenience method defined directly on the Gaussian process object. We could write the same in
the more succinctly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gp</span><span class="o">.</span><span class="n">posterior</span><span class="o">(</span><span class="n">regressionData</span><span class="o">)</span>
</code></pre></div></div>

<p>Independently of how you call the method, the returned type is a continuous (low rank) Gaussian Process from which we can now sample deformations at any set of points:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">posteriorSample</span> <span class="k">:</span> <span class="kt">DiscreteField</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">UnstructuredPointsDomain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> 
    <span class="k">=</span> <span class="n">posteriorGP</span><span class="o">.</span><span class="n">sampleAtPoints</span><span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">)</span>
<span class="k">val</span> <span class="n">posteriorSampleGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"posteriorSamples"</span><span class="o">)</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">posteriorSampleGroup</span><span class="o">,</span> <span class="n">posteriorSample</span><span class="o">,</span> <span class="s">"posteriorSample"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="posterior-of-a-statisticalmeshmodel">Posterior of a StatisticalMeshModel:</h3>

<p>Given that the StatisticalMeshModel is merely a wrapper around a GP, the same posterior functionality is available for statistical mesh models:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">littleNoise</span> <span class="k">=</span> <span class="nc">MultivariateNormalDistribution</span><span class="o">(</span><span class="nc">DenseVector</span><span class="o">.</span><span class="n">zeros</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">),</span> <span class="nc">DenseMatrix</span><span class="o">.</span><span class="n">eye</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span> <span class="o">*</span> <span class="mf">0.01</span><span class="o">)</span>
<span class="k">val</span> <span class="n">pointOnLargeNose</span> <span class="k">=</span> <span class="n">noseTipReference</span> <span class="o">+</span> <span class="n">noseTipDeformation</span>
<span class="k">val</span> <span class="n">discreteTrainingData</span> <span class="k">=</span> <span class="nc">IndexedSeq</span><span class="o">((</span><span class="nc">PointId</span><span class="o">(</span><span class="mi">8156</span><span class="o">),</span> <span class="n">pointOnLargeNose</span><span class="o">,</span> <span class="n">littleNoise</span><span class="o">))</span>
<span class="k">val</span> <span class="n">meshModelPosterior</span> <span class="k">:</span> <span class="kt">StatisticalMeshModel</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">posterior</span><span class="o">(</span><span class="n">discreteTrainingData</span><span class="o">)</span>
</code></pre></div></div>

<p>Notice in this case, since we are working with a discrete Gaussian process, the observed data is specified in terms of the <em>point identifier</em> of the nose tip point instead of its 3D coordinates.</p>

<p>Let’s visualize the obtained posterior model:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">posteriorModelGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"posteriorModel"</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">posteriorModelGroup</span><span class="o">,</span> <span class="n">meshModelPosterior</span><span class="o">,</span> <span class="s">"NoseyModel"</span><span class="o">)</span>
</code></pre></div></div>

<p><em>Exercise: sample a few random faces from the graphical interface using the random button. Notice how all faces display large noses :) with the tip of the nose remaining close to the selected landmark.</em></p>

<p>Here again we obtain much more than just a single face instance fitting the input data: we get a full normal distribution of shapes fitting the observation. The <strong>most probable</strong> shape, and hence our best fit, is the <strong>mean</strong> of the posterior.</p>

<p>We notice by sampling from the posterior model that we tend to get faces with rather large noses. This is since we chose our observation to be twice the length of the
average (mean) deformation at the tip of the nose.</p>

<h4 id="landmark-uncertainty">Landmark uncertainty:</h4>

<p>When we are specifying the training data for the posterior GP computation,
we model the uncertainty of the input data. The variance of this
noise model has a large influence on the resulting posterior distribution.
We should choose it always such that it corresponds as closely as possible to
the real uncertainty of our observation.</p>

<p>To see how this variance influences the posterior, we perform the posterior computation again with,
this time, a 5 times bigger noise variance.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">largeNoise</span> <span class="k">=</span> <span class="nc">MultivariateNormalDistribution</span><span class="o">(</span><span class="nc">DenseVector</span><span class="o">.</span><span class="n">zeros</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">),</span> <span class="nc">DenseMatrix</span><span class="o">.</span><span class="n">eye</span><span class="o">[</span><span class="kt">Double</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span> <span class="o">*</span> <span class="mf">5.0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">discreteTrainingDataLargeNoise</span> <span class="k">=</span> <span class="nc">IndexedSeq</span><span class="o">((</span><span class="nc">PointId</span><span class="o">(</span><span class="mi">8156</span><span class="o">),</span> <span class="n">pointOnLargeNose</span><span class="o">,</span> <span class="n">largeNoise</span><span class="o">))</span>
<span class="k">val</span> <span class="n">discretePosteriorLargeNoise</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">posterior</span><span class="o">(</span><span class="n">discreteTrainingDataLargeNoise</span><span class="o">)</span>
<span class="k">val</span> <span class="n">posteriorGroupLargeNoise</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"posteriorLargeNoise"</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">posteriorGroupLargeNoise</span><span class="o">,</span> <span class="n">discretePosteriorLargeNoise</span><span class="o">,</span> <span class="s">"NoisyNoseyModel"</span><span class="o">)</span>
</code></pre></div></div>

<p>We observe, that there is now much more variance left in this posterior process,
which is a consequence of the larger uncertainty that was associated with the
observed data.</p>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalismo.github.io/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script>((window.gitter = {}).chat = {}).options = {
room: 'marcelluethi/scalismo.github.io'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/scalismo.github.io/js/main.js"></script></body></html>
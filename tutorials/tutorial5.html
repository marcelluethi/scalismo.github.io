<html><head><title>scalismo: Rigid alignment</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="University of Basel" /><meta name="description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="image" property="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="og:title" content="scalismo: Rigid alignment" /><meta name="title" property="og:title" content="scalismo: Rigid alignment" /><meta name="og:site_name" content="scalismo" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><link rel="icon" type="image/png" href="/scalismo.github.io/img/favicon.png" /><meta name="twitter:title" content="scalismo: Rigid alignment" /><meta name="twitter:image" content="/scalismo.github.io/img/poster.png" /><meta name="twitter:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/scalismo.github.io/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/scalismo.github.io/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/scalismo.github.io/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/scalismo.github.io/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/scalismo.github.io/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/scalismo.github.io/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/scalismo.github.io/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/scalismo.github.io/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/scalismo.github.io/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/scalismo.github.io/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/scalismo.github.io/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/scalismo.github.io/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/scalismo.github.io/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/scalismo.github.io/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/scalismo.github.io/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/scalismo.github.io/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/scalismo.github.io/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/scalismo.github.io/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/scalismo.github.io/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/scalismo.github.io/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalismo.github.io/highlight/styles/default.css" /><link rel="stylesheet" href="/scalismo.github.io/css/style.css" /><link rel="stylesheet" href="/scalismo.github.io/css/palette.css" /><link rel="stylesheet" href="/scalismo.github.io/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalismo.github.io/" class="brand"><div class="brand-wrapper"><span>scalismo</span></div></a></li> <li><a href="/scalismo.github.io/tutorials/tutorial1.html" class="">Hello Scalismo</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial2.html" class=" active ">Rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial3.html" class="">From meshes to deformation fields</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial4.html" class="">Gaussian processes and Point Distribution Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial5.html" class="">Gaussian processes, sampling and marginalization</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial6.html" class="">Building a shape model from data</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial7.html" class="">Gaussian processes and kernels</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial8.html" class="">Posterior Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial9.html" class="">Shape completion</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial10.html" class="">ICP for rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial11.html" class="">Model fitting with ICP</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial12.html" class="">Parametric, non-rigid registration</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial13.html" class="">Active Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - The basic framework</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - Fitting a shape model</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="marcelluethi" data-github-repo="scalismo.github.io"><div class="content-wrapper"><section><head>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
        </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<h1 id="gaussian-processes-sampling-and-marginalization">Gaussian processes, sampling and marginalization</h1>

<p>In this tutorial we will experiment with sampling and marginalization of
Gaussian processes. Furthermore, we will learn how to compare the
likelihood of instances of our model.</p>

<h5 id="related-resources">Related resources</h5>

<p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling">online course</a> may provide
some helpful context for this tutorial:</p>

<ul>
  <li>The marginalization property <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250339">(Video)</a></li>
  <li>Sampling from a shape model <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250340">(Article)</a></li>
</ul>

<h5 id="preparation">Preparation</h5>

<p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.geometry._</span>
<span class="k">import</span> <span class="nn">scalismo.common._</span>
<span class="k">import</span> <span class="nn">scalismo.ui.api._</span>
<span class="k">import</span> <span class="nn">scalismo.mesh._</span>
<span class="k">import</span> <span class="nn">scalismo.io.StatisticalModelIO</span>
<span class="k">import</span> <span class="nn">scalismo.statisticalmodel._</span>

<span class="n">scalismo</span><span class="o">.</span><span class="n">initialize</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">rng</span> <span class="k">=</span> <span class="n">scalismo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="nc">Random</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ui</span> <span class="k">=</span> <span class="nc">ScalismoUI</span><span class="o">()</span>
</code></pre></div></div>

<h4 id="discrete-and-continuous-gaussian-processes">Discrete and Continuous Gaussian processes</h4>

<p>We have seen in the last tutorial that a Point Distribution Model (PDM)
is represented in Scalismo as a (discrete) Gaussian process over deformation fields,
defined on a reference mesh.</p>

<p>To continue our exploration of Gaussian processes, we therefore start
by loading (and visualizing) an existing PDM and retrieve its underlying
Gaussian process</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">model</span> <span class="k">=</span> <span class="nc">StatisticalModelIO</span><span class="o">.</span><span class="n">readStatisticalMeshModel</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/bfm.h5"</span><span class="o">)).</span><span class="n">get</span>
<span class="k">val</span> <span class="n">gp</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">gp</span>

<span class="k">val</span> <span class="n">modelGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"modelGroup"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">ssmView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">model</span><span class="o">,</span> <span class="s">"model"</span><span class="o">)</span>
</code></pre></div></div>

<p>We can retrieve random samples from the Gaussian process by calling <code class="highlighter-rouge">sample</code>
on the <code class="highlighter-rouge">gp</code> object:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">sampleDF</span> <span class="k">:</span> <span class="kt">DiscreteField</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>,<span class="kt">UnstructuredPointsDomain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> 
    <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">sample</span>

<span class="k">val</span> <span class="n">sampleGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"sample"</span><span class="o">)</span>  
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">sampleGroup</span><span class="o">,</span> <span class="n">sampleDF</span><span class="o">,</span> <span class="s">"discreteSample"</span><span class="o">)</span>
</code></pre></div></div>

<p>Note that the sampled vector field is <strong>discrete</strong>; I.e. is
defined over a <strong>discrete set of points</strong>.
This is due to the fact that our Gaussian Process is stored in a file
and was therefore discretized over the points of the reference mesh.</p>

<p>As seen in the previous tutorial, we could interpolate the
sample <code class="highlighter-rouge">sampleDf</code> to obtain a continuous version of the deformation field.
A more convenient approach is, however, to interpolate the
Gaussian process directly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">interpolator</span> <span class="k">=</span> <span class="nc">NearestNeighborInterpolator</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]()</span>
<span class="k">val</span> <span class="n">contGP</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">interpolate</span><span class="o">(</span><span class="n">interpolator</span><span class="o">)</span>
</code></pre></div></div>

<p>When we sample now from the continuous GP, we obtain a vector-valued function,
which is defined on the entire 3D Space:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">contSample</span><span class="k">:</span> <span class="kt">Field</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="n">contGP</span><span class="o">.</span><span class="n">sample</span>
</code></pre></div></div>

<p><em>Attention: While the interpolated Gaussian process is now defined on the entire 3D Space, the interpolation really only makes sense close to the mesh points</em>.</p>

<h2 id="from-continuous-to-discrete-marginalization">From continuous to discrete: marginalization</h2>

<p>In practice, we will never work with a continuous Gaussian process directly.
We are always interested in the distribution on a finite set of points. <br />
The real advantage of having a continuous Gaussian process is, that we can
get samples at <em>any</em> finite set of points and thereby choosing the discretization
according to the needs of our application.</p>

<p>To illustrate this, we could, for example obtain a sample,
which is defined on all the points of the original reference mesh.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">fullSample</span> <span class="k">=</span> <span class="n">contGP</span><span class="o">.</span><span class="n">sampleAtPoints</span><span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">)</span>
<span class="k">val</span> <span class="n">fullSampleView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">sampleGroup</span><span class="o">,</span> <span class="n">fullSample</span><span class="o">,</span> <span class="s">"fullSample"</span><span class="o">)</span>
</code></pre></div></div>

<p>We can also obtain samples which are defined only at a single point:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fullSampleView</span><span class="o">.</span><span class="n">remove</span><span class="o">()</span>
<span class="k">val</span> <span class="n">singlePointDomain</span> <span class="k">:</span> <span class="kt">DiscreteDomain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> 
    <span class="nc">UnstructuredPointsDomain</span><span class="o">(</span><span class="nc">IndexedSeq</span><span class="o">(</span><span class="n">model</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="nc">PointId</span><span class="o">(</span><span class="mi">8156</span><span class="o">))))</span>
<span class="k">val</span> <span class="n">singlePointSample</span> <span class="k">=</span> <span class="n">contGP</span><span class="o">.</span><span class="n">sampleAtPoints</span><span class="o">(</span><span class="n">singlePointDomain</span><span class="o">)</span> 
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">sampleGroup</span><span class="o">,</span> <span class="n">singlePointSample</span><span class="o">,</span> <span class="s">"singlePointSample"</span><span class="o">)</span>
</code></pre></div></div>

<p>(This should show a vector at the tip of the nose, which, could also be behind the face)</p>

<p>The marginalization property of a Gaussian process makes it possible not only
to obtain samples at an arbitrary set of points, but also the
distribution at these points. We can
obtain this distribution, by calling the method <code class="highlighter-rouge">marginal</code>
on the Gaussian process instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">referencePointSet</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">referenceMesh</span><span class="o">.</span><span class="n">pointSet</span>
<span class="k">val</span> <span class="n">rightEyePt</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">referencePointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="nc">PointId</span><span class="o">(</span><span class="mi">4281</span><span class="o">))</span>
<span class="k">val</span> <span class="n">leftEyePt</span><span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">referencePointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="nc">PointId</span><span class="o">(</span><span class="mi">11937</span><span class="o">))</span>
<span class="k">val</span> <span class="n">dom</span> <span class="k">=</span> <span class="nc">UnstructuredPointsDomain</span><span class="o">(</span><span class="nc">IndexedSeq</span><span class="o">(</span><span class="n">rightEyePt</span><span class="o">,</span><span class="n">leftEyePt</span><span class="o">))</span>
<span class="k">val</span> <span class="n">marginal</span> <span class="k">:</span> <span class="kt">DiscreteGaussianProcess</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">UnstructuredPointsDomain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="n">contGP</span><span class="o">.</span><span class="n">marginal</span><span class="o">(</span><span class="n">dom</span><span class="o">)</span>
</code></pre></div></div>

<p>The result of marginalization is again a discrete Gaussian process.
Sampling from this new Gaussian process yields a discrete deformation field, which
is defined only at the two points over which we marginalized:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">sample</span> <span class="k">:</span> <span class="kt">DiscreteField</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">UnstructuredPointsDomain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="n">marginal</span><span class="o">.</span><span class="n">sample</span> 
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">sampleGroup</span><span class="o">,</span> <span class="n">sample</span><span class="o">,</span> <span class="s">"marginal_sample"</span><span class="o">)</span> 
</code></pre></div></div>

<p>It seems that we are back where we started. But note that we have
now choosen a completly different set of points
on which the Gaussian process is defined.
This is important, as we can choose for any application that
discretization of the Gaussian process, which is most useful.</p>

<h2 id="marginal-of-a-statistical-mesh-model">Marginal of a statistical mesh model</h2>

<p>Given that a <em>StatisticalMeshModel</em> is in reality just a wrapper
around a GP, it naturally allows for marginalization as well:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">noseTipModel</span> <span class="k">:</span> <span class="kt">StatisticalMeshModel</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">marginal</span><span class="o">(</span><span class="nc">IndexedSeq</span><span class="o">(</span><span class="nc">PointId</span><span class="o">(</span><span class="mi">8156</span><span class="o">)))</span>
</code></pre></div></div>

<p>Notice in this case, how the passed argument to the marginal function
is an indexed sequence of point <strong>identifiers</strong> instead of a discrete domain.<br />
This is due to the fact that we are marginalizing a discrete Gaussian process.
Since the domain of the GP is already discrete, marginalization in this
case is done by selecting a subset of the discrete domain.
Hence the use of point identifiers instead of 3D coordinates.</p>

<p>Not surprisingly, we can again sample from this nose tip model:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">tipSample</span> <span class="k">:</span> <span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">noseTipModel</span><span class="o">.</span><span class="n">sample</span>
<span class="c1">// tipSample: TriangleMesh[_3D] = TriangleMesh3D(
//   scalismo.common.UnstructuredPointsDomain3D@6e15e143,
//   TriangleList(Vector())
// )
</span><span class="n">println</span><span class="o">(</span><span class="s">"nb mesh points "</span> <span class="o">+</span> <span class="n">tipSample</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">numberOfPoints</span><span class="o">)</span>
<span class="c1">// nb mesh points 1
</span></code></pre></div></div>

<p>Given that the marginal model is a <em>StatisticalMeshModel</em>, sampling from it
returns a <code class="highlighter-rouge">TriangleMesh</code>. When inspecting the points of the
returned sample, we see that it contains only one point, the nose tip.</p>

<h4 id="nose-marginal">Nose marginal</h4>

<p>Let’s suppose that we have a full model of the face, but are only
interested in the shape variations around the nose.
Marginalization let’s us achieve this easily.
To do so, we extract all points which lie within a specified distance
around the middle of the nose:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">middleNose</span> <span class="k">=</span> <span class="n">referencePointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="nc">PointId</span><span class="o">(</span><span class="mi">8152</span><span class="o">))</span>
<span class="k">val</span> <span class="n">nosePtIDs</span> <span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">PointId</span><span class="o">]</span> <span class="k">=</span> <span class="n">referencePointSet</span><span class="o">.</span><span class="n">pointsWithId</span>
  <span class="o">.</span><span class="n">filter</span><span class="o">(</span> <span class="n">ptAndId</span> <span class="k">=&gt;</span> <span class="o">{</span>  <span class="c1">// yields tuples with point and ids
</span>   <span class="k">val</span> <span class="o">(</span><span class="n">pt</span><span class="o">,</span> <span class="n">id</span><span class="o">)</span> <span class="k">=</span> <span class="n">ptAndId</span>
   <span class="o">(</span><span class="n">pt</span> <span class="o">-</span> <span class="n">middleNose</span><span class="o">).</span><span class="n">norm</span> <span class="o">&gt;</span> <span class="mi">40</span>
   <span class="o">})</span>   
  <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">ptAndId</span> <span class="k">=&gt;</span> <span class="n">ptAndId</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span> <span class="c1">// extract the id's   
</span></code></pre></div></div>

<p>We can now use the point ids to marginalize our shape model:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">noseModel</span> <span class="k">=</span> <span class="n">model</span><span class="o">.</span><span class="n">marginal</span><span class="o">(</span><span class="n">nosePtIDs</span><span class="o">.</span><span class="n">toIndexedSeq</span><span class="o">)</span>
<span class="k">val</span> <span class="n">noseGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"noseModel"</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">noseGroup</span><span class="o">,</span> <span class="n">noseModel</span><span class="o">,</span> <span class="s">"noseModel"</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="probability-of-shapes-and-deformations">Probability of shapes and deformations:</h2>

<p>It is often interesting to assess how probable a model instance is.
This can be done in Scalismo by means of the method <code class="highlighter-rouge">pdf</code>
(which stands for probability density function) of the class <code class="highlighter-rouge">GaussianProcess</code>
and <code class="highlighter-rouge">StatisticalMeshModel</code> respectively.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">defSample</span> <span class="k">=</span> <span class="n">noseModel</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">sample</span>
<span class="n">noseModel</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">pdf</span><span class="o">(</span><span class="n">defSample</span><span class="o">)</span>
</code></pre></div></div>

<p>The value of the <em>pdf</em> is often not interesting as such. But it allows us to compare the likelihood of different instances, by comparing their density value.
For numerical reasons, we usually work with the log probability:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">defSample1</span> <span class="k">=</span> <span class="n">noseModel</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">sample</span>
<span class="c1">// defSample1: DiscreteField[_3D, UnstructuredPointsDomain[_3D], EuclideanVector[_3D]] = &lt;function1&gt;
</span><span class="k">val</span> <span class="n">defSample2</span> <span class="k">=</span> <span class="n">noseModel</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">sample</span>
<span class="c1">// defSample2: DiscreteField[_3D, UnstructuredPointsDomain[_3D], EuclideanVector[_3D]] = &lt;function1&gt;
</span>
<span class="k">val</span> <span class="n">logPDF1</span> <span class="k">=</span> <span class="n">noseModel</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">logpdf</span><span class="o">(</span><span class="n">defSample1</span><span class="o">)</span>
<span class="c1">// logPDF1: Double = -11.265529462996712
</span><span class="k">val</span> <span class="n">logPDF2</span> <span class="k">=</span> <span class="n">noseModel</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">logpdf</span><span class="o">(</span><span class="n">defSample2</span><span class="o">)</span>
<span class="c1">// logPDF2: Double = -17.33330521109113
</span>
<span class="k">val</span> <span class="n">moreOrLess</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">logPDF1</span> <span class="o">&gt;</span> <span class="n">logPDF2</span><span class="o">)</span> <span class="s">"more"</span> <span class="k">else</span> <span class="s">"less"</span>
<span class="c1">// moreOrLess: String = "more"
</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"defSample1 is $moreOrLess likely than defSample2"</span><span class="o">)</span>
<span class="c1">// defSample1 is more likely than defSample2
</span></code></pre></div></div>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalismo.github.io/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script>((window.gitter = {}).chat = {}).options = {
room: 'marcelluethi/scalismo.github.io'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/scalismo.github.io/js/main.js"></script></body></html>
<html><head><title>scalismo: Rigid alignment</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="University of Basel" /><meta name="description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="image" property="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="og:title" content="scalismo: Rigid alignment" /><meta name="title" property="og:title" content="scalismo: Rigid alignment" /><meta name="og:site_name" content="scalismo" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><link rel="icon" type="image/png" href="/scalismo.github.io/img/favicon.png" /><meta name="twitter:title" content="scalismo: Rigid alignment" /><meta name="twitter:image" content="/scalismo.github.io/img/poster.png" /><meta name="twitter:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/scalismo.github.io/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/scalismo.github.io/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/scalismo.github.io/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/scalismo.github.io/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/scalismo.github.io/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/scalismo.github.io/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/scalismo.github.io/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/scalismo.github.io/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/scalismo.github.io/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/scalismo.github.io/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/scalismo.github.io/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/scalismo.github.io/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/scalismo.github.io/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/scalismo.github.io/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/scalismo.github.io/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/scalismo.github.io/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/scalismo.github.io/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/scalismo.github.io/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/scalismo.github.io/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/scalismo.github.io/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalismo.github.io/highlight/styles/default.css" /><link rel="stylesheet" href="/scalismo.github.io/css/style.css" /><link rel="stylesheet" href="/scalismo.github.io/css/palette.css" /><link rel="stylesheet" href="/scalismo.github.io/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalismo.github.io/" class="brand"><div class="brand-wrapper"><span>scalismo</span></div></a></li> <li><a href="/scalismo.github.io/tutorials/tutorial1.html" class="">Hello Scalismo</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial2.html" class=" active ">Rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial3.html" class="">From meshes to deformation fields</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial4.html" class="">Gaussian processes and Point Distribution Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial5.html" class="">Gaussian processes, sampling and marginalization</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial6.html" class="">Building a shape model from data</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial7.html" class="">Gaussian processes and kernels</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial8.html" class="">Posterior Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial9.html" class="">Shape completion</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial10.html" class="">ICP for rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial11.html" class="">Model fitting with ICP</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial12.html" class="">Parametric, non-rigid registration</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial13.html" class="">Active Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - The basic framework</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - Fitting a shape model</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="marcelluethi" data-github-repo="scalismo.github.io"><div class="content-wrapper"><section><head>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
        </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<h1 id="building-a-shape-model-from-data">Building a shape model from data</h1>

<p>The goal in this tutorial is to learn how to build a Statistical Shape Model
from meshes in correspondence. Furthermore, we discuss the importance of rigid alignment while doing so.</p>

<h5 id="related-resources">Related resources</h5>

<p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling">online course</a> may provide
some helpful context for this tutorial:</p>

<ul>
  <li>Learning a model from example data <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250329">(Video)</a></li>
</ul>

<h5 id="preparation">Preparation</h5>

<p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.geometry._</span>
<span class="k">import</span> <span class="nn">scalismo.common._</span>
<span class="k">import</span> <span class="nn">scalismo.ui.api._</span>
<span class="k">import</span> <span class="nn">scalismo.mesh._</span>
<span class="k">import</span> <span class="nn">scalismo.io.</span><span class="o">{</span><span class="nc">StatisticalModelIO</span><span class="o">,</span> <span class="nc">MeshIO</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scalismo.statisticalmodel._</span>
<span class="k">import</span> <span class="nn">scalismo.registration._</span>
<span class="k">import</span> <span class="nn">scalismo.statisticalmodel.dataset._</span>

<span class="n">scalismo</span><span class="o">.</span><span class="n">initialize</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">rng</span> <span class="k">=</span> <span class="n">scalismo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="nc">Random</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ui</span> <span class="k">=</span> <span class="nc">ScalismoUI</span><span class="o">()</span>
</code></pre></div></div>

<h3 id="loading-and-preprocessing-a-dataset">Loading and preprocessing a dataset:</h3>

<p>Let us load (and visualize) a set of face meshes based on which we would like to model shape variation:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">dsGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"datasets"</span><span class="o">)</span>

<span class="k">val</span> <span class="n">meshFiles</span> <span class="k">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/nonAlignedFaces/"</span><span class="o">).</span><span class="n">listFiles</span>

<span class="k">val</span> <span class="o">(</span><span class="n">meshes</span><span class="o">,</span> <span class="n">meshViews</span><span class="o">)</span> <span class="k">=</span> <span class="n">meshFiles</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">meshFile</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">mesh</span> <span class="k">=</span> <span class="nc">MeshIO</span><span class="o">.</span><span class="n">readMesh</span><span class="o">(</span><span class="n">meshFile</span><span class="o">).</span><span class="n">get</span> 
  <span class="k">val</span> <span class="n">meshView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">dsGroup</span><span class="o">,</span> <span class="n">mesh</span><span class="o">,</span> <span class="s">"mesh"</span><span class="o">)</span>
  <span class="o">(</span><span class="n">mesh</span><span class="o">,</span> <span class="n">meshView</span><span class="o">)</span> <span class="c1">// return a tuple of the mesh and the associated view
</span><span class="o">})</span> <span class="o">.</span><span class="n">unzip</span> <span class="c1">// take the tuples apart, to get a sequence of meshes and one of meshViews 
</span></code></pre></div></div>

<p>You immediately see that the meshes are not aligned. What you cannot see, but is
very important for this tutorial, is
that the meshes are <strong>in correspondence</strong>.
This means that for every point on one of the face meshes
(corner of eye, tip of nose, …), we can identify the corresponding point on
other meshes.  Corresponding points are identified by the same point id.</p>

<p><em>Exercise: verify that the meshes are indeed in correspondence by displaying a few corresponding points.</em></p>

<h4 id="rigidly-aligning-the-data">Rigidly aligning the data:</h4>

<p>In order to study shape variations, we need to eliminate variations due to
relative spatial displacement of the shapes (rotation and translation).
This can be achieved by selecting one of the meshes as a reference,
to which the rest of the datasets are aligned.
In this example here, we simply take the first mesh in the list as a reference and align all the others.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">reference</span> <span class="k">=</span> <span class="n">meshes</span><span class="o">.</span><span class="n">head</span>
<span class="k">val</span> <span class="n">toAlign</span> <span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">TriangleMesh</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="n">meshes</span><span class="o">.</span><span class="n">tail</span>
</code></pre></div></div>

<p>Given that our dataset is in correspondence, we can specify a set of point
identifiers, to locate corresponding points on the meshes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">pointIds</span> <span class="k">=</span> <span class="nc">IndexedSeq</span><span class="o">(</span><span class="mi">2214</span><span class="o">,</span> <span class="mi">6341</span><span class="o">,</span> <span class="mi">10008</span><span class="o">,</span> <span class="mi">14129</span><span class="o">,</span> <span class="mi">8156</span><span class="o">,</span> <span class="mi">47775</span><span class="o">)</span>
<span class="k">val</span> <span class="n">refLandmarks</span> <span class="k">=</span> <span class="n">pointIds</span><span class="o">.</span><span class="n">map</span><span class="o">{</span><span class="n">id</span> <span class="k">=&gt;</span> <span class="nc">Landmark</span><span class="o">(</span><span class="n">s</span><span class="s">"L_$id"</span><span class="o">,</span> <span class="n">reference</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="nc">PointId</span><span class="o">(</span><span class="n">id</span><span class="o">)))</span> <span class="o">}</span>
</code></pre></div></div>

<p>After locating the landmark positions on the reference, we iterate on each remaining data item, identify the corresponding landmark points and then rigidly align the mesh to the reference.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">alignedMeshes</span> <span class="k">=</span> <span class="n">toAlign</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">mesh</span> <span class="k">=&gt;</span>    
     <span class="k">val</span> <span class="n">landmarks</span> <span class="k">=</span> <span class="n">pointIds</span><span class="o">.</span><span class="n">map</span><span class="o">{</span><span class="n">id</span> <span class="k">=&gt;</span> <span class="nc">Landmark</span><span class="o">(</span><span class="s">"L_"</span><span class="o">+</span><span class="n">id</span><span class="o">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="nc">PointId</span><span class="o">(</span><span class="n">id</span><span class="o">)))}</span>
     <span class="k">val</span> <span class="n">rigidTrans</span> <span class="k">=</span> <span class="nc">LandmarkRegistration</span><span class="o">.</span><span class="n">rigid3DLandmarkRegistration</span><span class="o">(</span><span class="n">landmarks</span><span class="o">,</span> <span class="n">refLandmarks</span><span class="o">,</span> <span class="n">center</span> <span class="k">=</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">))</span>
     <span class="n">mesh</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span><span class="n">rigidTrans</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, the IndexedSeq of triangle meshes <em>alignedMeshes</em> contains the faces that are aligned to the reference mesh.</p>

<p><em>Exercise: verify visually that at least the first element of the aligned dataset is indeed aligned to the reference.</em></p>

<h3 id="building-a-discrete-gaussian-process-from-data">Building a discrete Gaussian process from data</h3>

<p>Now that we have a set of meshes, which are in correspondence and aligned
to our reference, we can turn the dataset into a set of deformation fields,
from which we then build the model:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">defFields</span> <span class="k">=</span> <span class="n">alignedMeshes</span><span class="o">.</span><span class="n">map</span><span class="o">{</span> <span class="n">m</span> <span class="k">=&gt;</span> 
    <span class="k">val</span> <span class="n">deformationVectors</span> <span class="k">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">pointIds</span><span class="o">.</span><span class="n">map</span><span class="o">{</span> <span class="n">id</span> <span class="k">:</span> <span class="kt">PointId</span> <span class="o">=&gt;</span>  
    <span class="n">m</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-</span> <span class="n">reference</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
  <span class="o">}.</span><span class="n">toIndexedSeq</span>

  <span class="nc">DiscreteField</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">UnstructuredPointsDomain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]](</span><span class="n">reference</span><span class="o">.</span><span class="n">pointSet</span><span class="o">,</span> <span class="n">deformationVectors</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Learning the shape variations from this deformation fields is
done by calling the method <code class="highlighter-rouge">createUsingPCA</code> of the
<code class="highlighter-rouge">DiscreteLowRankGaussianProcess</code> class.
Note that the deformation fields need to be interpolated, such that we are sure that they are defined on
all the points of the reference mesh.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">interpolator</span> <span class="k">=</span> <span class="nc">NearestNeighborInterpolator</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]()</span>
<span class="k">val</span> <span class="n">continuousFields</span> <span class="k">=</span> <span class="n">defFields</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">interpolate</span><span class="o">(</span><span class="n">interpolator</span><span class="o">)</span> <span class="o">)</span>
<span class="k">val</span> <span class="n">gp</span> <span class="k">=</span> <span class="nc">DiscreteLowRankGaussianProcess</span><span class="o">.</span><span class="n">createUsingPCA</span><span class="o">(</span><span class="n">reference</span><span class="o">.</span><span class="n">pointSet</span><span class="o">,</span> <span class="n">continuousFields</span><span class="o">)</span>
</code></pre></div></div>

<p><em>Exercise: display the mean deformation field of the returned Gaussian Process.</em></p>

<p><em>Exercise: sample and display a few deformation fields from this GP.</em></p>

<p><em>Exercise: using the GP’s *cov</em> method, evaluate the sample covariance between two close points on the right cheek first, and a point on the nose and one on the cheek second. What does the data tell you?*</p>

<p>By combining this Gaussian process over deformation fields with the reference mesh,
we obtain a Statistical Mesh Model:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">model</span> <span class="k">=</span> <span class="nc">StatisticalMeshModel</span><span class="o">(</span><span class="n">reference</span><span class="o">,</span> <span class="n">gp</span><span class="o">.</span><span class="n">interpolate</span><span class="o">(</span><span class="n">interpolator</span><span class="o">))</span>
</code></pre></div></div>

<p>Notice that when we visualize this mesh model in Scalismo-ui,
it generates a GaussianProcessTransformation and the reference mesh in the
Scene Tree of Scalismo-ui. .</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">modelGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"model"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">ssmView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup</span><span class="o">,</span> <span class="n">model</span><span class="o">,</span> <span class="s">"model"</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="an-easier-way-to-build-a-model">An easier way to build a model.</h3>

<p>Performing all the operations above every time we want to build a PCA model
from a set of files containing meshes in correspondence can be tedious.
Therefore, Scalismo provides a more easy to use implementation via the
<em>DataCollection</em> data structure.</p>

<p>The <em>DataCollection</em> class in Scalismo allows grouping together a dataset of meshes in correspondence,
in order to make collective operations on such sets easier.</p>

<p>We can create a <em>DataCollection</em> by providing a reference mesh, and
a sequence of meshes, which are in correspondence with this reference.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">dc</span> <span class="k">=</span> <span class="nc">DataCollection</span><span class="o">.</span><span class="n">fromMeshSequence</span><span class="o">(</span><span class="n">reference</span><span class="o">,</span> <span class="n">alignedMeshes</span><span class="o">).</span><span class="n">_1</span><span class="o">.</span><span class="n">get</span>
</code></pre></div></div>

<p>For each mesh, the data collection automatically computes
the transformation, which transforms the reference into the respective mesh:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">item0</span> <span class="k">:</span><span class="kt">DataItem</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">dc</span><span class="o">.</span><span class="n">dataItems</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">transform</span> <span class="k">:</span> <span class="kt">Transformation</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">item0</span><span class="o">.</span><span class="n">transformation</span>
</code></pre></div></div>

<p>Now that we have our data collection, we can build a shape model as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">modelNonAligned</span> <span class="k">=</span> <span class="nc">StatisticalMeshModel</span><span class="o">.</span><span class="n">createUsingPCA</span><span class="o">(</span><span class="n">dc</span><span class="o">).</span><span class="n">get</span>

<span class="k">val</span> <span class="n">modelGroup2</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"modelGroup2"</span><span class="o">)</span>
<span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">modelGroup2</span><span class="o">,</span> <span class="n">modelNonAligned</span><span class="o">,</span> <span class="s">"nonAligned"</span><span class="o">)</span>
</code></pre></div></div>

<p>Here again, a PCA is performed based the deformation fields
retrieved from the data in correspondence.</p>

<p>Notice that, in this case, we built a model from <strong>misaligned</strong> meshes
in correspondence.</p>

<p><em>Exercise: sample a few faces from the second model. How does the quality of the obtained shapes compare to the model built from aligned data?</em></p>

<p><em>Exercise: using the GUI, change the coefficient of the first principal component of the nonAligned shape model. What is the main shape variation encoded in the model?</em></p>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalismo.github.io/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script>((window.gitter = {}).chat = {}).options = {
room: 'marcelluethi/scalismo.github.io'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/scalismo.github.io/js/main.js"></script></body></html>
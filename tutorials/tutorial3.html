<html><head><title>scalismo: Rigid alignment</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="University of Basel" /><meta name="description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="image" property="og:image" content="/scalismo.github.io/img/poster.png" /><meta name="og:title" content="scalismo: Rigid alignment" /><meta name="title" property="og:title" content="scalismo: Rigid alignment" /><meta name="og:site_name" content="scalismo" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><link rel="icon" type="image/png" href="/scalismo.github.io/img/favicon.png" /><meta name="twitter:title" content="scalismo: Rigid alignment" /><meta name="twitter:image" content="/scalismo.github.io/img/poster.png" /><meta name="twitter:description" content="Scalismo - Scalable Image Analysis and Shape Modelling " /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/scalismo.github.io/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/scalismo.github.io/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/scalismo.github.io/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/scalismo.github.io/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/scalismo.github.io/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/scalismo.github.io/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/scalismo.github.io/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/scalismo.github.io/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/scalismo.github.io/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/scalismo.github.io/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/scalismo.github.io/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/scalismo.github.io/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/scalismo.github.io/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/scalismo.github.io/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/scalismo.github.io/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/scalismo.github.io/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/scalismo.github.io/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/scalismo.github.io/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/scalismo.github.io/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/scalismo.github.io/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/scalismo.github.io/highlight/styles/default.css" /><link rel="stylesheet" href="/scalismo.github.io/css/style.css" /><link rel="stylesheet" href="/scalismo.github.io/css/palette.css" /><link rel="stylesheet" href="/scalismo.github.io/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/scalismo.github.io/" class="brand"><div class="brand-wrapper"><span>scalismo</span></div></a></li> <li><a href="/scalismo.github.io/tutorials/tutorial1.html" class="">Hello Scalismo</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial2.html" class=" active ">Rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial3.html" class="">From meshes to deformation fields</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial4.html" class="">Gaussian processes and Point Distribution Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial5.html" class="">Gaussian processes, sampling and marginalization</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial6.html" class="">Building a shape model from data</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial7.html" class="">Gaussian processes and kernels</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial8.html" class="">Posterior Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial9.html" class="">Shape completion</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial10.html" class="">ICP for rigid alignment</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial11.html" class="">Model fitting with ICP</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial12.html" class="">Parametric, non-rigid registration</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial13.html" class="">Active Shape Models</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - The basic framework</a></li> <li><a href="/scalismo.github.io/tutorials/tutorial14.html" class="">Model fitting using MCMC - Fitting a shape model</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/marcelluethi/scalismo.github.io"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('scalismo Scalismo - Scalable Image Analysis and Shape Modelling ');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="marcelluethi" data-github-repo="scalismo.github.io"><div class="content-wrapper"><section><head>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"] ],
              processEscapes: true
            }
          });
        </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>

<h1 id="from-meshes-to-deformation-fields">From meshes to deformation fields</h1>

<p><em>In this tutorial, we show how the deformation fields that relate two meshes can be computed and visualized.</em></p>

<h5 id="related-resources">Related resources</h5>

<p>The following resources from our <a href="https://www.futurelearn.com/courses/statistical-shape-modelling">online course</a> may provide
some helpful context for this tutorial:</p>

<ul>
  <li>Modelling Shape Deformations <a href="https://www.futurelearn.com/courses/statistical-shape-modelling/3/steps/250326">(Video)</a></li>
</ul>

<h5 id="preparation">Preparation</h5>

<p>As in the previous tutorials, we start by importing some commonly used objects and initializing the system.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.geometry._</span>
<span class="k">import</span> <span class="nn">scalismo.common._</span>
<span class="k">import</span> <span class="nn">scalismo.ui.api._</span>
<span class="k">import</span> <span class="nn">scalismo.registration.Transformation</span>

<span class="n">scalismo</span><span class="o">.</span><span class="n">initialize</span><span class="o">()</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">rng</span> <span class="k">=</span> <span class="n">scalismo</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="nc">Random</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>

<span class="k">val</span> <span class="n">ui</span> <span class="k">=</span> <span class="nc">ScalismoUI</span><span class="o">()</span>
</code></pre></div></div>

<p>We will also load three meshes and visualize them in Scalismo-ui.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalismo.io.MeshIO</span>

<span class="k">val</span> <span class="n">dsGroup</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">createGroup</span><span class="o">(</span><span class="s">"datasets"</span><span class="o">)</span>

<span class="k">val</span> <span class="n">meshFiles</span> <span class="k">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">"datasets/testFaces/"</span><span class="o">).</span><span class="n">listFiles</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="o">(</span><span class="n">meshes</span><span class="o">,</span> <span class="n">meshViews</span><span class="o">)</span> <span class="k">=</span> <span class="n">meshFiles</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">meshFile</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">mesh</span> <span class="k">=</span> <span class="nc">MeshIO</span><span class="o">.</span><span class="n">readMesh</span><span class="o">(</span><span class="n">meshFile</span><span class="o">).</span><span class="n">get</span> 
  <span class="k">val</span> <span class="n">meshView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">dsGroup</span><span class="o">,</span> <span class="n">mesh</span><span class="o">,</span> <span class="s">"mesh"</span><span class="o">)</span>
  <span class="o">(</span><span class="n">mesh</span><span class="o">,</span> <span class="n">meshView</span><span class="o">)</span> <span class="c1">// return a tuple of the mesh and the associated view
</span><span class="o">})</span> <span class="o">.</span><span class="n">unzip</span> <span class="c1">// take the tuples apart, to get a sequence of meshes and one of meshViews 
</span>
</code></pre></div></div>

<h3 id="representing-meshes-as-deformations">Representing meshes as deformations</h3>

<p>In the following we show how we can represent a mesh as a reference mesh plus a deformation field. This is possible
because the meshes are all in correspondence; I.e. they all have the same number of points and points with the same id in the meshes represent
the same point/region in the mesh.</p>

<p>Let’s say <em>face_0</em>, is the reference mesh:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">reference</span> <span class="k">=</span> <span class="n">meshes</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="c1">// face_0 is our reference
</span></code></pre></div></div>

<p>Now any mesh, which is in correspondence with this reference, can be represented as a deformation field.
The deformation field is defined on this reference mesh; I.e. the points of
the reference mesh are the domain on which the deformation field is defined.</p>

<p>The deformations can be computed by taking the difference between the corresponding
point of the mesh and the reference:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">deformations</span> <span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">pointIds</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span>
  <span class="n">id</span> <span class="k">=&gt;</span>  <span class="n">meshes</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-</span> <span class="n">reference</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
<span class="o">}.</span><span class="n">toIndexedSeq</span>
</code></pre></div></div>

<p>From these deformations, we can then create a <code class="highlighter-rouge">DiscreteVectorField</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">deformationField</span> <span class="k">=</span> <span class="nc">DiscreteField</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">UnstructuredPointsDomain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]](</span><span class="n">reference</span><span class="o">.</span><span class="n">pointSet</span><span class="o">,</span> <span class="n">deformations</span><span class="o">)</span>
</code></pre></div></div>

<p>Similar to discrete scalar images, a Discrete Vector Field is defined
over a discrete domain. In contrast to images, the domain does not need to be
structured (a grid for example) and can be any arbitrary finite set of points. In the above example code, we defined the domain to be the reference mesh points, which
is of type <code class="highlighter-rouge">UnstructuredPointsDomain[_3D]</code>, as we can easily check:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">refDomain</span> <span class="k">:</span> <span class="kt">UnstructuredPointsDomain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">pointSet</span>
<span class="c1">// refDomain: UnstructuredPointsDomain[_3D] = scalismo.common.UnstructuredPointsDomain3D@e36f4d21
</span><span class="n">deformationField</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">refDomain</span>
<span class="c1">// res1: Boolean = true
</span></code></pre></div></div>

<p>As for images, the deformation vector associated with a particular point id in a <em>DiscreteVectorField</em> can be retrieved via its point id:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">deformationField</span><span class="o">(</span><span class="nc">PointId</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
<span class="c1">// res2: EuclideanVector[_3D] = EuclideanVector3D(
//   -0.031402587890625,
//   -0.24579620361328125,
//   4.780601501464844
// )
</span></code></pre></div></div>

<p>We can visualize this deformation field in Scalismo-ui using the usual <code class="highlighter-rouge">show</code>
command:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">deformationFieldView</span> <span class="k">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">dsGroup</span><span class="o">,</span> <span class="n">deformationField</span><span class="o">,</span> <span class="s">"deformations"</span><span class="o">)</span>
</code></pre></div></div>

<p>We can see that the deformation vectors indeed point from the reference to <em>face_1</em>.
To see the effect better we need to remove <em>face2</em> from the ui,
make the reference transparent</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">meshViews</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="n">remove</span><span class="o">()</span>
<span class="n">meshViews</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">opacity</span> <span class="k">=</span> <span class="mf">0.3</span>
</code></pre></div></div>

<p><em>Exercise: generate the rest of the deformation fields that represent the rest of the faces in the dataset and display them.</em></p>

<h3 id="deformation-fields-over-continuous-domains">Deformation fields over continuous domains:</h3>

<p>The deformation field that we computed above is discrete as it is
defined only over the mesh points. Since the real-world objects that we
model are continuous, and the discretization of our meshes is rather
arbitrary, this is not ideal. In Scalismo we usually prefer to work with
continuous domains.
Whenever we have an object in Scalismo, which is defined on a discrete domain,
we can obtain a continuous representation, by means
of interpolation.</p>

<p>To turn our deformation field into a continuous deformation field, we need to define an <code class="highlighter-rouge">Interpolator</code> and call the <code class="highlighter-rouge">interpolate</code>
method:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">interpolator</span> <span class="k">=</span> <span class="nc">NearestNeighborInterpolator</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]()</span>
<span class="k">val</span> <span class="n">continuousDeformationField</span> <span class="k">:</span> <span class="kt">Field</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]]</span> <span class="k">=</span> <span class="n">deformationField</span><span class="o">.</span><span class="n">interpolate</span><span class="o">(</span><span class="n">interpolator</span><span class="o">)</span>
</code></pre></div></div>

<p>As we do not know much about the structure of the points that define the mesh,
we use a <code class="highlighter-rouge">NearestNeighborInterpolator</code>, which means that for every point on
which we want to evaluate the deformation, the nearest point on the mesh is
found and returned.</p>

<p>The resulting  deformation field is now defined over the entire real space and
can be evaluated at any 3D Point:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">continuousDeformationField</span><span class="o">(</span><span class="nc">Point</span><span class="o">(-</span><span class="mi">100</span><span class="o">,-</span><span class="mi">100</span><span class="o">,-</span><span class="mi">100</span><span class="o">))</span>
<span class="c1">// res5: EuclideanVector[_3D] = EuclideanVector3D(
//   7.967502593994141,
//   1.7736968994140625,
//   -6.764269828796387
// )
</span></code></pre></div></div>

<p><em>Remark: This approach is general: Any discrete object in Scalismo can be interpolated.
For more structured domains, such as the <code class="highlighter-rouge">DiscreteImageDomain</code>, we can use
more sophisticated interpolation schemes, such as linear or b-spline interpolation.</em></p>

<h3 id="the-mean-deformation-and-the-mean-mesh">The mean deformation and the mean mesh</h3>

<p>Given a set of meshes, we are often interested to compute mesh that represents the mean shape.
This is equivalent to computing the mean deformation <script type="math/tex">\overline{u}</script>, and to apply this deformation to them mean mesh.</p>

<p>To compute the mean deformation, we compute for each point in our mesh the sample mean of the
deformations at this point in the deformation fields:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">val</span> <span class="n">nMeshes</span> <span class="k">=</span> <span class="n">meshes</span><span class="o">.</span><span class="n">length</span>

<span class="k">val</span> <span class="n">meanDeformations</span> <span class="k">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">pointIds</span><span class="o">.</span><span class="n">map</span><span class="o">(</span> <span class="n">id</span> <span class="k">=&gt;</span> <span class="o">{</span>

  <span class="k">var</span> <span class="n">meanDeformationForId</span> <span class="k">=</span> <span class="nc">EuclideanVector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">meanDeformations</span> <span class="k">=</span> <span class="n">meshes</span><span class="o">.</span><span class="n">foreach</span> <span class="o">(</span><span class="n">mesh</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="c1">// loop through meshes
</span>    <span class="k">val</span> <span class="n">deformationAtId</span> <span class="k">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-</span> <span class="n">reference</span><span class="o">.</span><span class="n">pointSet</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
    <span class="n">meanDeformationForId</span> <span class="o">+=</span> <span class="n">deformationAtId</span> <span class="o">*</span> <span class="o">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">nMeshes</span><span class="o">)</span>
  <span class="o">})</span>

  <span class="n">meanDeformationForId</span>
<span class="o">})</span>

<span class="k">val</span> <span class="n">meanDeformationField</span> <span class="k">=</span> <span class="nc">DiscreteField</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span>, <span class="kt">UnstructuredPointsDomain</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]</span>, <span class="kt">EuclideanVector</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">]](</span>
  <span class="n">reference</span><span class="o">.</span><span class="n">pointSet</span><span class="o">,</span> 
  <span class="n">meanDeformations</span><span class="o">.</span><span class="n">toIndexedSeq</span>
<span class="o">)</span>
</code></pre></div></div>

<p>We can now apply the deformation to every point of the reference mesh, to obtain the mean mesh.
To do this, the easiest way is to first genenerate a transformation from the deformation field, which
we can use to map every point of the reference to its mean:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">continuousMeanDeformationField</span> <span class="k">=</span> <span class="n">meanDeformationField</span><span class="o">.</span><span class="n">interpolate</span><span class="o">(</span><span class="n">interpolator</span><span class="o">)</span>

<span class="k">val</span> <span class="n">meanTransformation</span> <span class="k">=</span> <span class="nc">Transformation</span><span class="o">((</span><span class="n">pt</span> <span class="k">:</span> <span class="kt">Point</span><span class="o">[</span><span class="k">_</span><span class="err">3</span><span class="kt">D</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">pt</span> <span class="o">+</span> <span class="n">continuousMeanDeformationField</span><span class="o">(</span><span class="n">pt</span><span class="o">))</span>    
</code></pre></div></div>

<p>To obtain the mean mesh, we simply apply this transformation to the reference mesh:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">meanMesh</span> <span class="k">=</span> <span class="n">reference</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span><span class="n">meanTransformation</span><span class="o">)</span>
</code></pre></div></div>

<p>Finally, we display the result:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ui</span><span class="o">.</span><span class="n">show</span><span class="o">(</span><span class="n">dsGroup</span><span class="o">,</span> <span class="n">meanMesh</span><span class="o">,</span> <span class="s">"mean mesh"</span><span class="o">)</span>
</code></pre></div></div>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/scalismo.github.io/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script>((window.gitter = {}).chat = {}).options = {
room: 'marcelluethi/scalismo.github.io'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/scalismo.github.io/js/main.js"></script></body></html>